/**
 * Tasks Service
 *
 * Manages kitchen tasks assigned to cooks/stations
 * Tasks are stored in Firestore under users/{userId}/tasks
 */

import {
  collection,
  doc,
  getDocs,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  onSnapshot,
  serverTimestamp,
  Timestamp
} from 'firebase/firestore';
import { db, auth } from '../database/firebase';
import { convertUnits, areUnitsCompatible } from '../../utils/unitConversion';

// Task statuses
export const TASK_STATUS = {
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  PAUSED: 'paused',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled'
};

// Collection name
const TASKS_COLLECTION = 'tasks';

/**
 * Get the tasks collection reference for current user
 */
function getTasksCollection() {
  const user = auth.currentUser;
  if (!user) throw new Error('User not authenticated');
  return collection(db, 'users', user.uid, TASKS_COLLECTION);
}

/**
 * Create a new task
 * @param {Object} taskData - Task data
 * @returns {Promise<string>} New task ID
 */
export async function createTask(taskData) {
  try {
    const {
      recipeId,
      recipeName,
      portions,
      portionUnit,     // Unit for portions (L, kg, portions, etc.)
      scaleFactor,
      assignedTo,      // Privilege ID or name
      assignedToName,  // Display name
      station,
      department,      // Department name for team view
      dueDate,
      dueTime,
      chefNotes,
      priority,
      type,            // 'recipe' or 'custom'
      // Dependency tracking (Phase 2)
      dependsOn,       // Array of task IDs that must complete first
      prerequisiteFor, // Task ID this was created to support
      autoGenerated,   // Was this task auto-created as a prerequisite?
      hasDependencies, // Does this task have dependencies?
    } = taskData;

    const tasksRef = getTasksCollection();

    // Convert date string to Timestamp if provided
    let dueDateTimestamp = null;
    if (dueDate) {
      const dateStr = dueTime ? `${dueDate}T${dueTime}` : `${dueDate}T23:59`;
      dueDateTimestamp = Timestamp.fromDate(new Date(dateStr));
    }

    const docRef = await addDoc(tasksRef, {
      type: type || 'recipe',
      recipeId: recipeId || null,
      recipeName,
      portions: portions || 1,
      portionUnit: portionUnit || '',
      scaleFactor: scaleFactor || 1,
      assignedTo: assignedTo || null,
      assignedToName: assignedToName || 'Team',
      station: station || null,
      department: department || null,
      dueDate: dueDateTimestamp,
      priority: priority || 'normal',
      status: TASK_STATUS.PENDING,
      chefNotes: chefNotes || '',
      cookNotes: '',
      messages: [],
      startedAt: null,
      pausedAt: null,
      completedAt: null,
      totalTime: 0,  // In seconds
      // Dependency tracking
      dependsOn: dependsOn || [],
      prerequisiteFor: prerequisiteFor || null,
      autoGenerated: autoGenerated || false,
      hasDependencies: hasDependencies || false,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    return docRef.id;
  } catch (error) {
    console.error('Error creating task:', error);
    throw error;
  }
}

/**
 * Get all tasks for current user
 * @param {Object} options - Filter options
 * @returns {Promise<Array>} Array of tasks
 */
export async function getAllTasks(options = {}) {
  try {
    const tasksRef = getTasksCollection();
    let q = query(tasksRef, orderBy('createdAt', 'desc'));

    // Apply filters
    if (options.status) {
      q = query(tasksRef, where('status', '==', options.status), orderBy('createdAt', 'desc'));
    }
    if (options.assignedTo) {
      q = query(tasksRef, where('assignedTo', '==', options.assignedTo), orderBy('createdAt', 'desc'));
    }

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      dueDate: doc.data().dueDate?.toDate() || null,
      createdAt: doc.data().createdAt?.toDate() || null,
      updatedAt: doc.data().updatedAt?.toDate() || null,
      startedAt: doc.data().startedAt?.toDate() || null,
      completedAt: doc.data().completedAt?.toDate() || null
    }));
  } catch (error) {
    console.error('Error getting tasks:', error);
    throw error;
  }
}

/**
 * Get a single task by ID
 * @param {string} taskId - Task ID
 * @returns {Promise<Object|null>} Task object or null
 */
export async function getTask(taskId) {
  try {
    const user = auth.currentUser;
    if (!user) throw new Error('User not authenticated');

    const taskRef = doc(db, 'users', user.uid, TASKS_COLLECTION, taskId);
    const taskDoc = await getDoc(taskRef);

    if (!taskDoc.exists()) return null;

    const data = taskDoc.data();
    return {
      id: taskDoc.id,
      ...data,
      dueDate: data.dueDate?.toDate() || null,
      createdAt: data.createdAt?.toDate() || null,
      updatedAt: data.updatedAt?.toDate() || null,
      startedAt: data.startedAt?.toDate() || null,
      completedAt: data.completedAt?.toDate() || null
    };
  } catch (error) {
    console.error('Error getting task:', error);
    throw error;
  }
}

/**
 * Update task status
 * @param {string} taskId - Task ID
 * @param {string} status - New status
 * @param {Object} options - Optional: { createProductionLog: true, deductInventory: true }
 * @returns {Promise<Object>} Result with inventoryResults if deduction occurred
 */
export async function updateTaskStatus(taskId, status, options = {}) {
  try {
    const user = auth.currentUser;
    if (!user) throw new Error('User not authenticated');

    const taskRef = doc(db, 'users', user.uid, TASKS_COLLECTION, taskId);
    const updates = {
      status,
      updatedAt: serverTimestamp()
    };

    // Track timing
    if (status === TASK_STATUS.IN_PROGRESS) {
      updates.startedAt = serverTimestamp();
    } else if (status === TASK_STATUS.COMPLETED) {
      updates.completedAt = serverTimestamp();
    }

    await updateDoc(taskRef, updates);

    let inventoryResults = null;

    // When task completes, handle inventory deduction and production
    // ALL operations must succeed - no silent failures
    if (status === TASK_STATUS.COMPLETED) {
      const task = await getTask(taskId);
      if (!task) {
        throw new Error(`Task ${taskId} not found after status update`);
      }

      if (task.recipeId) {
        // Lazy import to avoid circular dependency
        const {
          productionLogDB,
          kitchenSettingsDB,
          recipeDB,
          inventoryItemDB,
          vendorDB
        } = await import('../database/indexedDB.js');
        const { deductStockFromTask } = await import('../inventory/stockService.js');
        const config = await kitchenSettingsDB.getRestrictionConfig();

        const recipe = await recipeDB.getById(task.recipeId);
        if (!recipe) {
          throw new Error(`Recipe ${task.recipeId} not found for task ${taskId}`);
        }

        // ========================================
        // 1. Deduct ingredients from inventory
        // ========================================
        if (recipe.ingredients && options.deductInventory !== false) {
          // Use new recipe deduction service with proper unit conversion
          const { deductRecipeIngredients } = await import('../inventory/recipeDeductionService.js');
          inventoryResults = await deductRecipeIngredients(recipe, task, user.uid);
        }

        // ========================================
        // 1b. Deduct packaging from inventory
        // ========================================
        if (recipe.platingInstructions && options.deductInventory !== false) {
          const { deductRecipePackaging } = await import('../inventory/recipeDeductionService.js');
          const packagingResults = await deductRecipePackaging(recipe, task, user.uid);

          // Merge packaging results into inventory results
          if (packagingResults.summary.total > 0) {
            inventoryResults.success.push(...packagingResults.success);
            inventoryResults.failed.push(...packagingResults.failed);
            inventoryResults.skipped.push(...packagingResults.skipped);
            inventoryResults.warnings.push(...packagingResults.warnings);
            inventoryResults.summary.total += packagingResults.summary.total;
            inventoryResults.summary.succeeded += packagingResults.summary.succeeded;
            inventoryResults.summary.failed += packagingResults.summary.failed;
            inventoryResults.summary.skipped += packagingResults.summary.skipped;
          }
        }

        // ========================================
        // 2. Add produced item(s) to inventory (MANDATORY)
        // Every completed task creates/updates inventory items
        // ========================================
        // Use execution data from task if available (contains actualWeights from execution mode)
        const methodStepsSource = task.executionData?.methodSteps || recipe.method;
        const productionSteps = getProductionSteps(methodStepsSource);

        if (productionSteps.length > 0) {
          // Multi-output production from method steps with producesItem: true
          // Only creates the specific items defined in method steps (e.g., "steak de longe de porc")
          const productionResults = await addProducedItemsFromMethodSteps(
            recipe,
            task,
            productionSteps,
            inventoryItemDB,
            vendorDB,
            inventoryResults, // Pass ingredient deduction results for cost calculation
            user.uid
          );
          if (productionResults) {
            inventoryResults = inventoryResults || {};
            inventoryResults.producedItems = productionResults.items;
            inventoryResults.packagingDeducted = productionResults.packagingDeducted;

            // Track sync warnings
            for (const item of productionResults.items || []) {
              if (item.syncError) {
                inventoryResults.syncWarnings = inventoryResults.syncWarnings || [];
                inventoryResults.syncWarnings.push({
                  type: 'production',
                  itemName: item.itemName,
                  error: item.syncError
                });
              }
            }
          }
        } else {
          // No production steps defined - create item using recipe name as fallback
          // This handles recipes without specific "producesItem" method steps
          const productionResult = await addProducedItemToInventory(
            recipe,
            task,
            inventoryItemDB,
            vendorDB,
            user.uid,
            inventoryResults // Pass ingredient deduction results for cost calculation
          );
          if (productionResult) {
            inventoryResults = inventoryResults || {};
            inventoryResults.producedItem = productionResult;

            // Track sync warnings
            if (productionResult.syncError) {
              inventoryResults.syncWarnings = inventoryResults.syncWarnings || [];
              inventoryResults.syncWarnings.push({
                type: 'production',
                itemName: productionResult.itemName,
                error: productionResult.syncError
              });
            }
          }
        }

        // ========================================
        // 3. Create production log (if enabled)
        // ========================================
        if (options.createProductionLog !== false && config.trackProduction) {
          await productionLogDB.createFromTask(task);
        }
      }
    }

    // Determine overall sync status
    const hasSyncWarnings = inventoryResults?.syncWarnings?.length > 0;
    const allSynced = !hasSyncWarnings && (inventoryResults?.producedItem?.synced !== false);

    return {
      success: true,
      inventoryResults,
      syncStatus: {
        allSynced,
        warnings: inventoryResults?.syncWarnings || [],
        message: hasSyncWarnings
          ? 'Task completed. Some items saved locally but sync pending.'
          : 'Task completed and synced successfully.'
      }
    };
  } catch (error) {
    console.error('Error updating task status:', error);
    throw error;
  }
}

/**
 * @deprecated Use recipeDeductionService.deductRecipeIngredients() instead.
 * This function has critical bugs with unit conversion (g→lb) and is no longer called.
 * Kept for reference during migration. Will be removed in next major version.
 *
 * Deduct ingredients from inventory when a task is completed
 * @param {Object} recipe - Recipe with ingredients array
 * @param {Object} task - Task with scaleFactor
 * @param {Function} deductStockFromTask - Stock deduction function
 * @param {Object} inventoryItemDB - Inventory item database for unit lookup
 * @param {string} userId - User ID for audit trail
 * @returns {Promise<Object>} Deduction results
 */
async function deductIngredientsFromTask(recipe, task, deductStockFromTask, inventoryItemDB, userId) {
  const results = {
    success: [],
    failed: [],
    skipped: [],
    alerts: []
  };

  const scaleFactor = task.scaleFactor || 1;

  for (const ingredient of recipe.ingredients) {
    // Skip section headers
    if (ingredient.isSection) {
      continue;
    }

    // Skip unlinked ingredients
    if (!ingredient.linkedIngredientId) {
      results.skipped.push({
        name: ingredient.name,
        reason: 'Not linked to inventory'
      });
      continue;
    }

    // Parse metric from string (e.g., "300g", "1.5kg", "500ml")
    // Ingredients store metric as a combined string, not separate qty/unit fields
    const metricString = ingredient.metric || ingredient.metricQty || '';
    const metricMatch = String(metricString).match(/^([\d.,]+)\s*(g|kg|ml|l|ea)?$/i);

    if (!metricMatch) {
      results.skipped.push({
        name: ingredient.name,
        reason: 'No metric quantity specified'
      });
      continue;
    }

    let baseQty = parseFloat(metricMatch[1].replace(',', '.')) || 0;
    let ingredientUnit = (metricMatch[2] || ingredient.metricUnit || 'g').toLowerCase();

    // Convert kg/L to base units (g/ml) for consistent deduction
    if (ingredientUnit === 'kg') {
      baseQty *= 1000;
      ingredientUnit = 'g';
    }
    if (ingredientUnit === 'l') {
      baseQty *= 1000;
      ingredientUnit = 'ml';
    }

    if (baseQty <= 0) {
      results.skipped.push({
        name: ingredient.name,
        reason: 'Metric quantity is zero'
      });
      continue;
    }

    const scaledQty = baseQty * scaleFactor;

    try {
      // Get the inventory item to check its unit
      const inventoryItem = await inventoryItemDB.getById(ingredient.linkedIngredientId);
      if (!inventoryItem) {
        results.failed.push({
          itemId: ingredient.linkedIngredientId,
          name: ingredient.linkedName || ingredient.name,
          quantity: scaledQty,
          error: 'Inventory item not found'
        });
        continue;
      }

      const itemUnit = inventoryItem.unit || 'ea';
      let deductQty = scaledQty;

      // Check if inventory item is weight-based (has pricePerG from invoice import)
      // These items have currentStock already stored in grams
      const isWeightBasedItem = inventoryItem.pricePerG > 0 ||
                                 inventoryItem.unitType === 'weight' ||
                                 (itemUnit && /\d+\s*(lb|lbs|kg|g|oz)/i.test(itemUnit));

      if (isWeightBasedItem && (ingredientUnit === 'g' || ingredientUnit === 'ml')) {
        // Weight-based item: currentStock is already in grams, deduct directly
        // No conversion needed, scaledQty is already in grams
      } else if (ingredientUnit !== itemUnit) {
        // Handle unit conversion if units differ
        // Check if units are compatible for conversion
        if (!areUnitsCompatible(ingredientUnit, itemUnit)) {
          results.failed.push({
            itemId: ingredient.linkedIngredientId,
            name: ingredient.linkedName || ingredient.name,
            quantity: scaledQty,
            error: `Cannot convert ${ingredientUnit} to ${itemUnit}`
          });
          continue;
        }

        // Convert the quantity
        const converted = convertUnits(scaledQty, ingredientUnit, itemUnit);
        if (converted === null) {
          results.failed.push({
            itemId: ingredient.linkedIngredientId,
            name: ingredient.linkedName || ingredient.name,
            quantity: scaledQty,
            error: `Unit conversion failed: ${ingredientUnit} to ${itemUnit}`
          });
          continue;
        }
        deductQty = converted;
      }

      const result = await deductStockFromTask(
        ingredient.linkedIngredientId,
        deductQty,
        task.id,
        {
          recipeId: recipe.id,
          recipeName: recipe.name,
          createdBy: userId,
          allowNegative: false // Will throw if insufficient stock
        }
      );

      results.success.push({
        itemId: ingredient.linkedIngredientId,
        itemName: result.itemName,
        quantity: deductQty,
        originalQuantity: scaledQty,
        originalUnit: ingredientUnit,
        convertedUnit: itemUnit,
        previousStock: result.previousStock,
        newStock: result.newStock
      });

      if (result.alert) {
        results.alerts.push(result.alertMessage);
      }
    } catch (error) {
      results.failed.push({
        itemId: ingredient.linkedIngredientId,
        name: ingredient.linkedName || ingredient.name,
        quantity: scaledQty,
        error: error.message
      });
    }
  }

  return results;
}

/**
 * Add produced item to inventory when a task is completed
 *
 * Maps recipe fields to inventory item fields following the same schema as invoice items:
 * - Volume items (L, ml): stockWeight, volumePerPc, pricingType='volume', isLiquid=true
 * - Weight items (kg, g): stockWeight, weightPerUnit, pricingType='weight'
 * - Count items (portion): stockQuantity, pricingType='unit'
 *
 * @param {Object} recipe - Recipe with portions, portionUnit, category, etc.
 * @param {Object} task - Task with portions and scaleFactor
 * @param {Object} inventoryItemDB - Inventory item database
 * @param {Object} vendorDB - Vendor database
 * @param {string} userId - User ID for audit trail
 * @param {Object} ingredientResults - Optional: deduction results for cost calculation
 * @returns {Promise<Object|null>} Created/updated inventory item with sync status
 */
async function addProducedItemToInventory(recipe, task, inventoryItemDB, vendorDB, userId, ingredientResults = null) {
  // ============================================
  // 1. Get or create internal vendor
  // ============================================
  let internalVendor = await vendorDB.getInternal();
  if (!internalVendor) {
    const vendorId = await vendorDB.create({
      name: 'In-House Production',
      vendorCode: 'INTERNAL',
      isInternal: true,
      isActive: true,
      notes: 'Auto-created for in-house production tracking',
    });
    internalVendor = await vendorDB.getById(vendorId);
  }

  // ============================================
  // 2. Calculate production quantity
  // ============================================
  // NOTE: task.portions already represents the desired output quantity (e.g., 40L)
  // scaleFactor is only used for ingredient deduction scaling, NOT for doubling production
  const producedQuantity = task.portions || recipe.portions || 1;

  // ============================================
  // 3. Detect unit type and pricing type
  // ============================================
  const portionUnit = (recipe.portionUnit || 'portion').toLowerCase();
  const volumeUnits = ['l', 'ml', 'cl', 'dl', 'liter', 'litre', 'liters', 'litres'];
  const weightUnits = ['kg', 'g', 'lb', 'lbs', 'oz', 'gram', 'grams', 'kilogram'];

  const isVolumeUnit = volumeUnits.includes(portionUnit);
  const isWeightUnit = weightUnits.includes(portionUnit);
  const isCountUnit = !isVolumeUnit && !isWeightUnit;

  // Determine pricing type (same as invoice items)
  const pricingType = isVolumeUnit ? 'volume' : isWeightUnit ? 'weight' : 'unit';

  // Normalize unit for storage
  const normalizedUnit = portionUnit === 'l' ? 'L' : portionUnit;

  // ============================================
  // 3b. Boxing format - container size for volume/weight recipes
  // ============================================
  // If recipe has outputContainerSize, use it to calculate containers
  // e.g., 60L produced with 20L containers = 3 containers
  const containerSize = recipe.outputContainerSize || null;
  const containerUnit = recipe.outputContainerUnit || normalizedUnit;

  // Calculate containers produced (only for volume/weight with boxing format)
  let containersProduced = 1; // Default to 1 container per production run
  if ((isVolumeUnit || isWeightUnit) && containerSize > 0) {
    containersProduced = Math.floor(producedQuantity / containerSize);
    // Ensure at least 1 container if there's any production
    if (containersProduced < 1 && producedQuantity > 0) {
      containersProduced = 1;
    }
  }

  // Calculate per-container amount for volumePerPc/weightPerUnit (in base units: ml or g)
  const perContainerBase = containerSize > 0
    ? (isVolumeUnit
        ? (containerUnit.toLowerCase() === 'l' ? containerSize * 1000 : containerSize)
        : (containerUnit.toLowerCase() === 'kg' ? containerSize * 1000 : containerSize))
    : (isVolumeUnit
        ? (portionUnit === 'l' ? producedQuantity * 1000 : producedQuantity)
        : (portionUnit === 'kg' ? producedQuantity * 1000 : producedQuantity));

  // ============================================
  // 4. Calculate cost if ingredient data available
  // ============================================
  let totalCost = null;
  let pricePerML = null;
  let pricePerG = null;
  let pricePerUnit = null;

  if (ingredientResults?.success?.length > 0) {
    // Sum up ingredient costs
    totalCost = ingredientResults.success.reduce((sum, d) => sum + (d.cost || 0), 0);

    if (totalCost > 0 && producedQuantity > 0) {
      if (isVolumeUnit) {
        // Convert to base unit (ml) for price calculation
        const totalML = portionUnit === 'l' ? producedQuantity * 1000 : producedQuantity;
        pricePerML = totalCost / totalML;
      } else if (isWeightUnit) {
        // Convert to base unit (g) for price calculation
        const totalG = portionUnit === 'kg' ? producedQuantity * 1000 : producedQuantity;
        pricePerG = totalCost / totalG;
      } else {
        pricePerUnit = totalCost / producedQuantity;
      }
    }
  }

  // ============================================
  // 5. Check for existing item
  // ============================================
  const itemName = recipe.name;
  const existingItem = await inventoryItemDB.getByVendorAndName(internalVendor.id, itemName);

  // ============================================
  // 6. Build item data following invoice item schema
  // ============================================
  const timestamp = new Date().toISOString();

  if (existingItem) {
    // ----------------------------------------
    // UPDATE existing item
    // ----------------------------------------
    let updateData = {
      lastProductionDate: timestamp,
      updatedAt: timestamp,
    };

    if (isVolumeUnit || isWeightUnit) {
      // Volume/weight: add to stockWeight AND add containers based on boxing format
      const currentStockWeight = existingItem.stockWeight ?? 0;
      const currentContainers = existingItem.stockQuantity ?? 0;
      const newStockWeight = currentStockWeight + producedQuantity;
      const newContainers = currentContainers + containersProduced;  // Add containers based on boxing format

      updateData = {
        ...updateData,
        // Stock tracking
        stockWeight: newStockWeight,
        stockWeightUnit: normalizedUnit,
        stockQuantity: newContainers,
        stockQuantityUnit: 'pc',  // Always 'pc' - this is container count, not volume
        // Per-pc info (for threshold deduction) - use boxing format size or existing
        ...(isVolumeUnit ? { volumePerPc: existingItem.volumePerPc || perContainerBase } : {}),
        ...(isWeightUnit ? { weightPerUnit: existingItem.weightPerUnit || perContainerBase } : {}),
        // Update cost if calculated (average with existing)
        ...(pricePerML !== null ? { pricePerML } : {}),
        ...(pricePerG !== null ? { pricePerG } : {}),
        ...(totalCost !== null ? { currentPrice: (existingItem.currentPrice || 0) + totalCost } : {}),
        // Legacy fields
        currentStock: newStockWeight,
        fullStock: Math.max(existingItem.fullStock || 0, newStockWeight),
      };
    } else {
      // Count: add to stockQuantity
      const currentQty = existingItem.stockQuantity ?? existingItem.currentStock ?? 0;
      const newQty = currentQty + producedQuantity;

      updateData = {
        ...updateData,
        stockQuantity: newQty,
        stockQuantityUnit: normalizedUnit,
        // Update cost if calculated
        ...(pricePerUnit !== null ? { pricePerUnit } : {}),
        ...(totalCost !== null ? { currentPrice: (existingItem.currentPrice || 0) + totalCost } : {}),
        // Legacy
        currentStock: newQty,
        fullStock: Math.max(existingItem.fullStock || 0, newQty),
        parQuantity: Math.max(existingItem.parQuantity || 0, newQty),
      };
    }

    // Persist update
    let synced = false;
    let syncError = null;

    if (inventoryItemDB.updateWithSync) {
      const result = await inventoryItemDB.updateWithSync(existingItem.id, updateData, { requireSync: false });
      synced = result.synced;
      syncError = result.syncError;
    } else {
      await inventoryItemDB.update(existingItem.id, updateData);
    }

    const newStockValue = updateData.stockWeight ?? updateData.stockQuantity;

    return {
      action: 'updated',
      itemId: existingItem.id,
      itemName: existingItem.name,
      addedQuantity: producedQuantity,
      newStock: newStockValue,
      batchCount: updateData.stockQuantity,
      unit: normalizedUnit,
      totalCost,
      synced,
      syncError,
    };

  } else {
    // ----------------------------------------
    // CREATE new item (full schema like invoice items)
    // ----------------------------------------

    const itemData = {
      // ===== Identity =====
      name: itemName,
      nameNormalized: itemName.toLowerCase().trim(),
      vendorId: internalVendor.id,
      vendorName: internalVendor.name,
      category: recipe.category || 'Prepared Items',

      // ===== Source (recipe linkage) =====
      sourceRecipeId: recipe.id,
      sourceRecipeName: recipe.name,
      sourceDepartment: recipe.department || null,

      // ===== Classification =====
      itemType: 'in-house',
      pricingType,
      isLiquid: isVolumeUnit,
      isVolumeBased: isVolumeUnit,
      isWeightBased: isWeightUnit,
      isInternal: true,

      // ===== Stock Tracking =====
      ...(isVolumeUnit || isWeightUnit ? {
        stockWeight: producedQuantity,
        stockWeightUnit: normalizedUnit,
        stockQuantity: containersProduced,  // Containers based on boxing format
        stockQuantityUnit: 'pc',  // Always 'pc' - this is container count, not volume
      } : {
        stockQuantity: producedQuantity,
        stockQuantityUnit: normalizedUnit,
      }),

      // ===== Per-Unit Info (for threshold deduction) =====
      ...(isVolumeUnit ? { volumePerPc: perContainerBase } : {}),
      ...(isWeightUnit ? { weightPerUnit: perContainerBase } : {}),

      // ===== Pricing (only if cost data available) =====
      ...(pricePerML !== null ? { pricePerML } : {}),
      ...(pricePerG !== null ? { pricePerG } : {}),
      ...(pricePerUnit !== null ? { pricePerUnit } : {}),
      ...(totalCost !== null ? { currentPrice: totalCost } : {}),

      // ===== Par Levels =====
      ...(isVolumeUnit || isWeightUnit ? {
        parWeight: producedQuantity,
      } : {
        parQuantity: producedQuantity,
        parLevel: producedQuantity,
      }),

      // ===== Flags =====
      isActive: true,
      availableForSale: recipe.availableForSale || false,
      availableAsIngredient: recipe.availableAsIngredient !== false, // Default true for in-house

      // ===== Metadata =====
      lastProductionDate: timestamp,
      createdAt: timestamp,
      updatedAt: timestamp,
      notes: `Auto-created from recipe: ${recipe.name}`,
      createdBy: userId,

      // ===== Legacy fields =====
      unit: normalizedUnit,
      currentStock: producedQuantity,
      fullStock: producedQuantity,
    };

    // Persist create
    let newItemId;
    let synced = false;
    let syncError = null;

    if (inventoryItemDB.createWithSync) {
      const result = await inventoryItemDB.createWithSync(itemData, { requireSync: false });
      newItemId = result.id;
      synced = result.synced;
      syncError = result.syncError;
    } else {
      newItemId = await inventoryItemDB.create(itemData);
    }

    return {
      action: 'created',
      itemId: newItemId,
      itemName,
      addedQuantity: producedQuantity,
      newStock: producedQuantity,
      batchCount: isVolumeUnit || isWeightUnit ? containersProduced : null,
      unit: normalizedUnit,
      totalCost,
      synced,
      syncError,
    };
  }
}

/**
 * Get production steps from recipe method array
 * @param {Array} method - Recipe method array (strings or objects)
 * @returns {Array} Steps that produce inventory items
 */
function getProductionSteps(method) {
  if (!Array.isArray(method)) return [];

  return method
    .map((step, index) => {
      // Handle both string and object format
      if (typeof step === 'string') {
        return null; // String steps don't produce items
      }
      if (step && step.producesItem) {
        return { ...step, stepIndex: index };
      }
      return null;
    })
    .filter(step => step !== null);
}

/**
 * Add multiple produced items from method steps
 * @param {Object} recipe - Recipe with method steps
 * @param {Object} task - Task with scaleFactor and completion data
 * @param {Array} productionSteps - Steps that produce items (from getProductionSteps)
 * @param {Object} inventoryItemDB - Inventory item database
 * @param {Object} vendorDB - Vendor database
 * @param {Object} ingredientResults - Results from ingredient deduction (for cost calculation)
 * @param {string} userId - User ID for audit trail
 * @returns {Promise<Object>} Results with items array and packaging deductions
 */
async function addProducedItemsFromMethodSteps(
  recipe,
  task,
  productionSteps,
  inventoryItemDB,
  vendorDB,
  ingredientResults,
  userId
) {
  // Get or create internal vendor for in-house production
  let internalVendor = await vendorDB.getInternal();
  if (!internalVendor) {
    // Auto-create internal vendor if missing
    const vendorId = await vendorDB.create({
      name: 'In-House Production',
      vendorCode: 'INTERNAL',
      isInternal: true,
      isActive: true,
      notes: 'Auto-created for in-house production tracking',
    });
    internalVendor = await vendorDB.getById(vendorId);
  }

  const portions = task.portions || 1;
  const scaleFactor = task.scaleFactor || 1;
  const results = {
    items: [],
    packagingDeducted: [],
    totalYield: 0,
    totalWaste: 0
  };

  // Calculate total input cost from deducted ingredients
  let totalInputCost = 0;
  if (ingredientResults?.success) {
    for (const deduction of ingredientResults.success) {
      totalInputCost += deduction.cost || 0;
    }
  }

  // Calculate total output weight (for proportional cost distribution)
  // Use portions (not scaleFactor) because expectedWeight is per portion
  let totalOutputWeight = 0;
  for (const step of productionSteps) {
    const weight = (step.actualWeight || step.expectedWeight || 0) * portions;
    totalOutputWeight += weight;
  }

  // Process each production step
  for (const step of productionSteps) {
    const outputName = step.outputName || `${recipe.name} - Step ${step.stepIndex + 1}`;

    // Get number of output items from boxing size or packaging quantity
    // If boxingSize is set: numberOfItems = expectedWeight / boxingSize (e.g., 10L / 1L = 10 containers)
    // Otherwise fall back to packaging quantity or portions
    const packagingItems = step.packagingItems || (step.packaging ? [step.packaging] : []);
    const primaryPackaging = packagingItems[0];
    const expectedWeight = step.expectedWeight || 0;
    const boxingSize = step.boxingSize || null;

    // Calculate number of items from boxing size
    let numberOfItems;
    if (boxingSize && boxingSize > 0 && expectedWeight > 0) {
      // Boxing size defined: 10L total / 1L per container = 10 containers
      numberOfItems = Math.round(expectedWeight / boxingSize);
    } else if (primaryPackaging?.quantity && primaryPackaging.quantity > 1) {
      // Explicit packaging quantity set
      numberOfItems = primaryPackaging.quantity;
    } else {
      // Fallback to portions
      numberOfItems = portions;
    }

    // Get unit from step
    const weightUnit = step.weightUnit || 'kg';
    const isVolumeBasedProduction = ['L', 'ml', 'l'].includes(weightUnit);

    // Expected weight is the TOTAL output (e.g., 10 L), not per-item
    const totalExpectedWeight = step.actualWeight || step.expectedWeight || 0;
    // Total weight = expected weight × task portions (for batch scaling)
    const actualWeight = totalExpectedWeight * portions;
    // Weight per item = total / number of items
    const weightPerItem = numberOfItems > 0 ? actualWeight / numberOfItems : actualWeight;
    const wasteWeight = (step.wasteWeight || 0) * scaleFactor;

    const isVolumeUnit = isVolumeBasedProduction;

    // Calculate proportional cost
    let itemCost = 0;
    let pricePerG = 0;
    let pricePerML = 0;
    if (totalInputCost > 0 && totalOutputWeight > 0 && actualWeight > 0) {
      itemCost = totalInputCost * (actualWeight / totalOutputWeight);
      if (isVolumeUnit) {
        // Convert to ML for pricePerML calculation
        const weightInML = weightUnit === 'L' || weightUnit === 'l' ? actualWeight * 1000 : actualWeight;
        pricePerML = itemCost / weightInML;
      } else {
        // Convert to grams for pricePerG calculation
        const weightInGrams = weightUnit === 'kg' ? actualWeight * 1000
          : weightUnit === 'lb' ? actualWeight * 453.592
          : actualWeight; // assume grams
        pricePerG = itemCost / weightInGrams;
      }
    }

    // Use precise lookup for existing item (search might miss due to name ordering)
    const existingItem = await inventoryItemDB.getByVendorAndName(internalVendor.id, outputName);

    let itemResult;

    if (existingItem) {
      // Update existing item - add to stock
      const newStockWeight = (existingItem.stockWeight || 0) + actualWeight;
      const newStockQuantity = (existingItem.stockQuantity || 0) + numberOfItems;

      let synced = false;
      let syncError = null;

      // Build update data with correct pricing field for volume vs weight
      const updateData = {
        stockWeight: newStockWeight,
        stockWeightUnit: weightUnit,
        stockQuantity: newStockQuantity,
        weightPerPortion: weightPerItem || existingItem.weightPerPortion,
        // Update boxing info from latest recipe run
        boxingSize: boxingSize || weightPerItem || existingItem.boxingSize,
        boxingSizeUnit: step.boxingSizeUnit || weightUnit || existingItem.boxingSizeUnit,
        lastProductionDate: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      // Set appropriate pricing field
      if (isVolumeUnit) {
        updateData.pricePerML = pricePerML || existingItem.pricePerML;
        updateData.pricingType = 'volume';
      } else {
        updateData.pricePerG = pricePerG || existingItem.pricePerG;
        updateData.pricingType = 'weight';
      }

      if (inventoryItemDB.updateWithSync) {
        const result = await inventoryItemDB.updateWithSync(existingItem.id, updateData, { requireSync: false });
        synced = result.synced;
        syncError = result.syncError;
      } else {
        await inventoryItemDB.update(existingItem.id, updateData);
      }

      itemResult = {
        action: 'updated',
        itemId: existingItem.id,
        itemName: outputName,
        addedWeight: actualWeight,
        newStockWeight,
        addedQuantity: numberOfItems,
        newStockQuantity,
        weightPerPortion: weightPerItem,
        unit: weightUnit,
        pricePerG: isVolumeUnit ? null : pricePerG,
        pricePerML: isVolumeUnit ? pricePerML : null,
        itemCost,
        synced,
        syncError
      };
    } else {
      // Create new inventory item
      const itemData = {
        name: outputName,
        vendorId: internalVendor.id,
        vendorName: internalVendor.name,
        category: recipe.category || 'In-House Production',
        unit: weightUnit,
        stockWeight: actualWeight,
        stockWeightUnit: weightUnit,
        stockQuantity: numberOfItems,
        stockQuantityUnit: 'pc', // Each output is one piece/container
        weightPerPortion: weightPerItem,
        // Boxing info from recipe (for display and traceability)
        boxingSize: boxingSize || weightPerItem,
        boxingSizeUnit: step.boxingSizeUnit || weightUnit,
        itemType: 'in-house',
        isActive: true,
        availableAsIngredient: true,
        sourceRecipeId: recipe.id,
        sourceRecipeName: recipe.name,
        sourceDepartment: recipe.department || null,
        sourceStepIndex: step.stepIndex,
        lastProductionDate: new Date().toISOString(),
        notes: step.text || `Produced from: ${recipe.name}`,
        createdBy: userId
      };
      // Set appropriate pricing field
      if (isVolumeUnit) {
        itemData.pricePerML = pricePerML;
        itemData.pricingType = 'volume';
        itemData.isLiquid = true;
      } else {
        itemData.pricePerG = pricePerG;
        itemData.pricingType = 'weight';
      }

      let newItemId;
      let synced = false;
      let syncError = null;

      if (inventoryItemDB.createWithSync) {
        const result = await inventoryItemDB.createWithSync(itemData, { requireSync: false });
        newItemId = result.id;
        synced = result.synced;
        syncError = result.syncError;
      } else {
        newItemId = await inventoryItemDB.create(itemData);
      }

      itemResult = {
        action: 'created',
        itemId: newItemId,
        itemName: outputName,
        addedWeight: actualWeight,
        newStockWeight: actualWeight,
        addedQuantity: numberOfItems,
        newStockQuantity: numberOfItems,
        weightPerPortion: weightPerItem,
        unit: weightUnit,
        pricePerG: isVolumeUnit ? null : pricePerG,
        pricePerML: isVolumeUnit ? pricePerML : null,
        itemCost,
        synced,
        syncError
      };
    }

    results.items.push(itemResult);
    results.totalYield += actualWeight;
    results.totalWaste += wasteWeight;

    // Deduct packaging items if specified (supports multiple packaging items per step)
    let totalPackagingCost = 0;

    for (const packaging of packagingItems) {
      if (!packaging?.itemId) continue;

      try {
        const packagingItem = await inventoryItemDB.getById(packaging.itemId);
        if (packagingItem) {
          const packagingQty = (packaging.quantity || 1) * scaleFactor;
          const newStock = Math.max(0, (packagingItem.currentStock || 0) - packagingQty);

          await inventoryItemDB.update(packaging.itemId, {
            currentStock: newStock,
            updatedAt: new Date().toISOString()
          });

          // Calculate packaging cost
          const packagingCost = (packagingItem.currentPrice || 0) * packagingQty;
          totalPackagingCost += packagingCost;

          results.packagingDeducted.push({
            itemId: packaging.itemId,
            itemName: packagingItem.name,
            quantity: packagingQty,
            cost: packagingCost,
            forOutput: outputName
          });
        }
      } catch (packagingError) {
        console.warn(`[tasksService] Failed to deduct packaging ${packaging.itemName || packaging.itemId} for ${outputName}:`, packagingError);
      }
    }

    // Add total packaging cost to item's pricePerG
    if (totalPackagingCost > 0 && itemResult.pricePerG > 0) {
      const weightInGrams = actualWeight * 1000;
      const additionalPricePerG = totalPackagingCost / weightInGrams;
      itemResult.pricePerG += additionalPricePerG;

      // Update the item with new pricePerG including all packaging costs
      await inventoryItemDB.update(itemResult.itemId, {
        pricePerG: itemResult.pricePerG
      });
    }
  }

  return results;
}

/**
 * Update task
 * @param {string} taskId - Task ID
 * @param {Object} updates - Fields to update
 * @returns {Promise<void>}
 */
export async function updateTask(taskId, updates) {
  try {
    const user = auth.currentUser;
    if (!user) throw new Error('User not authenticated');

    const taskRef = doc(db, 'users', user.uid, TASKS_COLLECTION, taskId);
    await updateDoc(taskRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error updating task:', error);
    throw error;
  }
}

/**
 * Add a message to task
 * @param {string} taskId - Task ID
 * @param {Object} message - Message object { from, text, timestamp }
 * @returns {Promise<void>}
 */
export async function addTaskMessage(taskId, message) {
  try {
    const task = await getTask(taskId);
    if (!task) throw new Error('Task not found');

    const messages = task.messages || [];
    messages.push({
      ...message,
      timestamp: new Date().toISOString()
    });

    await updateTask(taskId, { messages });
  } catch (error) {
    console.error('Error adding message:', error);
    throw error;
  }
}

/**
 * Delete a task
 * @param {string} taskId - Task ID
 * @returns {Promise<void>}
 */
export async function deleteTask(taskId) {
  try {
    const user = auth.currentUser;
    if (!user) throw new Error('User not authenticated');

    const taskRef = doc(db, 'users', user.uid, TASKS_COLLECTION, taskId);
    await deleteDoc(taskRef);
  } catch (error) {
    console.error('Error deleting task:', error);
    throw error;
  }
}

/**
 * Subscribe to tasks updates (real-time)
 * @param {Function} callback - Callback function (tasks) => void
 * @param {Object} options - Filter options
 * @returns {Function} Unsubscribe function
 */
export function subscribeToTasks(callback, options = {}) {
  try {
    const tasksRef = getTasksCollection();
    let q = query(tasksRef, orderBy('createdAt', 'desc'));

    if (options.status) {
      q = query(tasksRef, where('status', '==', options.status), orderBy('createdAt', 'desc'));
    }

    return onSnapshot(q, (snapshot) => {
      const tasks = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        dueDate: doc.data().dueDate?.toDate() || null,
        createdAt: doc.data().createdAt?.toDate() || null,
        updatedAt: doc.data().updatedAt?.toDate() || null,
        startedAt: doc.data().startedAt?.toDate() || null,
        completedAt: doc.data().completedAt?.toDate() || null
      }));
      callback(tasks);
    }, (error) => {
      console.error('Tasks subscription error:', error);
    });
  } catch (error) {
    console.error('Error subscribing to tasks:', error);
    throw error;
  }
}

/**
 * Get active tasks count
 * @returns {Promise<number>}
 */
export async function getActiveTasksCount() {
  try {
    const tasks = await getAllTasks();
    return tasks.filter(t =>
      t.status === TASK_STATUS.PENDING ||
      t.status === TASK_STATUS.IN_PROGRESS
    ).length;
  } catch (error) {
    console.error('Error getting active tasks count:', error);
    return 0;
  }
}

/**
 * Get today's tasks
 * @param {string} department - Optional department filter
 * @returns {Promise<Array>}
 */
export async function getTodaysTasks(department = null) {
  try {
    const allTasks = await getAllTasks();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    return allTasks.filter(task => {
      // Filter by department if provided
      if (department && task.department !== department) return false;

      // Include tasks due today or created today
      const isDueToday = task.dueDate && task.dueDate >= today && task.dueDate < tomorrow;
      const isCreatedToday = task.createdAt && task.createdAt >= today && task.createdAt < tomorrow;

      // Include active tasks (pending/in_progress) even if not due today
      const isActive = task.status === TASK_STATUS.PENDING || task.status === TASK_STATUS.IN_PROGRESS;

      return isDueToday || isCreatedToday || isActive;
    });
  } catch (error) {
    console.error('Error getting today\'s tasks:', error);
    return [];
  }
}

/**
 * Subscribe to department tasks (real-time)
 * @param {string} department - Department name
 * @param {Function} callback - Callback function (tasks) => void
 * @returns {Function} Unsubscribe function
 */
export function subscribeToDepartmentTasks(department, callback) {
  try {
    const tasksRef = getTasksCollection();
    const q = query(tasksRef, orderBy('createdAt', 'desc'));

    return onSnapshot(q, (snapshot) => {
      const allTasks = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        dueDate: doc.data().dueDate?.toDate() || null,
        createdAt: doc.data().createdAt?.toDate() || null,
        updatedAt: doc.data().updatedAt?.toDate() || null,
        startedAt: doc.data().startedAt?.toDate() || null,
        completedAt: doc.data().completedAt?.toDate() || null
      }));

      // Filter by department if specified, otherwise show all
      // Also include tasks without department (null/undefined) when filtering
      const tasks = department
        ? allTasks.filter(task => task.department === department || !task.department)
        : allTasks;

      callback(tasks);
    }, (error) => {
      console.error('Department tasks subscription error:', error);
    });
  } catch (error) {
    console.error('Error subscribing to department tasks:', error);
    throw error;
  }
}

/**
 * Get task progress stats for a department
 * @param {Array} tasks - Array of tasks
 * @returns {Object} Progress stats
 */
export function getTaskProgress(tasks) {
  const total = tasks.length;
  const completed = tasks.filter(t => t.status === TASK_STATUS.COMPLETED).length;
  const inProgress = tasks.filter(t => t.status === TASK_STATUS.IN_PROGRESS).length;
  const pending = tasks.filter(t => t.status === TASK_STATUS.PENDING).length;
  const paused = tasks.filter(t => t.status === TASK_STATUS.PAUSED).length;

  return {
    total,
    completed,
    inProgress,
    pending,
    paused,
    percentComplete: total > 0 ? Math.round((completed / total) * 100) : 0
  };
}

/**
 * Claim a task (assign to current user)
 * @param {string} taskId - Task ID
 * @param {string} privilegeId - Privilege ID of the user claiming
 * @param {string} privilegeName - Name of the user claiming
 * @returns {Promise<void>}
 */
export async function claimTask(taskId, privilegeId, privilegeName) {
  try {
    await updateTask(taskId, {
      assignedTo: privilegeId,
      assignedToName: privilegeName,
      status: TASK_STATUS.IN_PROGRESS,
      startedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error claiming task:', error);
    throw error;
  }
}

/**
 * Release a task (unassign from current user)
 * @param {string} taskId - Task ID
 * @returns {Promise<void>}
 */
export async function releaseTask(taskId) {
  try {
    await updateTask(taskId, {
      assignedTo: null,
      assignedToName: 'Team',
      status: TASK_STATUS.PENDING,
      startedAt: null
    });
  } catch (error) {
    console.error('Error releasing task:', error);
    throw error;
  }
}

// ============================================
// TASK CLEANUP FUNCTIONS
// ============================================

/**
 * Clear all completed tasks (manual button action)
 * Production logs are preserved - only the active task is deleted
 * @returns {Promise<{deleted: number, errors: number}>}
 */
export async function clearCompletedTasks() {
  try {
    const tasksRef = getTasksCollection();
    const q = query(tasksRef, where('status', '==', TASK_STATUS.COMPLETED));
    const snapshot = await getDocs(q);

    let deleted = 0;
    let errors = 0;

    for (const docSnapshot of snapshot.docs) {
      try {
        await deleteDoc(docSnapshot.ref);
        deleted++;
      } catch (err) {
        console.error(`Failed to delete task ${docSnapshot.id}:`, err);
        errors++;
      }
    }

    console.log(`[TaskCleanup] Cleared ${deleted} completed tasks (${errors} errors)`);
    return { deleted, errors };
  } catch (error) {
    console.error('Error clearing completed tasks:', error);
    throw error;
  }
}

/**
 * Cleanup completed tasks older than specified days
 * Called automatically at midnight or manually
 * @param {number} daysOld - Delete tasks completed more than X days ago (default: 1 = yesterday)
 * @returns {Promise<{deleted: number, errors: number}>}
 */
export async function cleanupOldCompletedTasks(daysOld = 1) {
  try {
    const tasksRef = getTasksCollection();
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    cutoffDate.setHours(0, 0, 0, 0); // Start of day

    // Query completed tasks
    const q = query(tasksRef, where('status', '==', TASK_STATUS.COMPLETED));
    const snapshot = await getDocs(q);

    let deleted = 0;
    let errors = 0;

    for (const docSnapshot of snapshot.docs) {
      const data = docSnapshot.data();
      const completedAt = data.completedAt?.toDate();

      // Skip if no completedAt or if completed after cutoff
      if (!completedAt || completedAt >= cutoffDate) {
        continue;
      }

      try {
        await deleteDoc(docSnapshot.ref);
        deleted++;
      } catch (err) {
        console.error(`Failed to delete old task ${docSnapshot.id}:`, err);
        errors++;
      }
    }

    console.log(`[TaskCleanup] Auto-cleaned ${deleted} tasks older than ${daysOld} day(s) (${errors} errors)`);
    return { deleted, errors };
  } catch (error) {
    console.error('Error cleaning up old tasks:', error);
    throw error;
  }
}

/**
 * Schedule daily cleanup at midnight
 * Call this once when the app initializes
 * @returns {Function} Cleanup function to stop the scheduler
 */
export function scheduleDailyTaskCleanup() {
  // Calculate ms until next midnight
  const now = new Date();
  const midnight = new Date(now);
  midnight.setDate(midnight.getDate() + 1);
  midnight.setHours(0, 0, 0, 0);
  const msUntilMidnight = midnight.getTime() - now.getTime();

  let dailyInterval = null;

  // First cleanup at midnight
  const firstTimeout = setTimeout(() => {
    cleanupOldCompletedTasks(1); // Clean tasks completed before today

    // Then schedule daily
    dailyInterval = setInterval(() => {
      cleanupOldCompletedTasks(1);
    }, 24 * 60 * 60 * 1000); // Every 24 hours
  }, msUntilMidnight);

  console.log(`[TaskCleanup] Scheduled daily cleanup in ${Math.round(msUntilMidnight / 1000 / 60)} minutes (at midnight)`);

  // Return cleanup function
  return () => {
    clearTimeout(firstTimeout);
    if (dailyInterval) {
      clearInterval(dailyInterval);
    }
  };
}
