<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitchen Recipe Manager - Voice Enabled</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2c3e50">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Recipes">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        // Suppress Babel standalone development warning for tablet deployment
        // Note: For future optimization, consider pre-compiling JSX to plain JavaScript
        if (window.Babel && window.Babel.disableScriptTags === undefined) {
            // Babel standalone is loaded and working correctly for tablet deployment
            console.log('‚úÖ Babel standalone loaded for JSX transformation');
        }
    </script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .app {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
        }
        
        /* Global Menu Bar */
        .menu-bar {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .app-name {
            font-size: 20px;
            font-weight: bold;
            flex: 1;
        }
        
        .menu-button {
            background: none;
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            min-width: 50px;
        }
        
        .menu-button:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .menu-button.active {
            background: #27ae60;
            border-color: #27ae60;
        }
        
        .menu-button.flag {
            background: none;
        }
        
        .menu-button.flag.active {
            background: #3498db;
            border-color: #3498db;
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 5px;
            background: white;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-radius: 8px;
            z-index: 1000;
            overflow: hidden;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: white;
            width: 100%;
            text-align: left;
            font-size: 16px;
            color: #2c3e50;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dropdown-item:hover {
            background: #ecf0f1;
        }

        .dropdown-item.danger {
            color: #e74c3c;
        }

        .dropdown-item.danger:hover {
            background: #fadbd8;
        }

        .dropdown-divider {
            height: 1px;
            background: #ecf0f1;
            margin: 5px 0;
        }

        /* Search Bar */
        .search-section {
            padding: 20px;
            background: white;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .search-bar {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            background: white;
        }
        
        .search-input {
            flex: 1;
            border: none;
            outline: none;
            font-size: 16px;
            padding: 5px;
        }
        
        .search-button {
            padding: 8px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .search-button:hover {
            background: #2980b9;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
        
        .input-button {
            padding: 8px 12px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            min-width: 40px;
        }
        
        .input-button.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        /* Voice Status Indicator */
        .voice-status {
            display: inline-block;
            padding: 4px 8px;
            background: #e74c3c;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 5px;
            animation: pulse 1.5s infinite;
        }
        
        /* Recipe List */
        .recipe-list {
            padding: 20px;
        }
        
        .recipe-button {
            width: 100%;
            padding: 15px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            font-size: 16px;
            transition: all 0.2s;
        }
        
        .recipe-button:hover {
            background: #ecf0f1;
            border-color: #3498db;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
            font-size: 18px;
        }
        
        /* Recipe Detail Page */
        .recipe-detail {
            padding: 20px;
        }
        
        .recipe-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #3498db;
        }
        
        .recipe-name {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .recipe-name:hover {
            border-color: #bdc3c7;
            background: #ecf0f1;
        }
        
        .portion-field {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
        }
        
        .portion-input {
            width: 80px;
            padding: 8px;
            font-size: 18px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            text-align: center;
        }
        
        /* Section Headers */
        .section {
            margin-bottom: 40px;
        }
        
        .section-header {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            text-transform: uppercase;
        }
        
        /* Ingredient Rows */
        .ingredient-row {
            display: grid;
            grid-template-columns: 40px 150px auto 1fr 40px;
            column-gap: 5px;
            padding: 6px 10px;
            border-bottom: 1px solid #ecf0f1;
            align-items: center;
            position: relative;
            min-height: 33px;
        }

        .ingredient-row.grouped {
            background: #e3f2fd;
        }

        .delete-row-btn {
            background: transparent;
            color: #95a5a6;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .delete-row-btn:hover {
            opacity: 1;
            color: #e74c3c;
        }
        
        .ingredient-cell {
            padding: 4px 8px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            min-height: 28px;
        }
        
        .ingredient-cell:hover {
            border-color: #bdc3c7;
            background: #ecf0f1;
        }
        
        .ingredient-cell.editing {
            border-color: #3498db;
            background: white;
        }
        
        /* Method and Plating Steps */
        .step-row {
            display: flex;
            gap: 10px;
            padding: 6px 10px;
            border-bottom: 1px solid #ecf0f1;
            align-items: center;
            min-height: 33px;
        }
        
        .step-number {
            font-weight: bold;
            color: #7f8c8d;
            min-width: 30px;
        }
        
        .step-text {
            flex: 1;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            min-height: 36px;
        }
        
        .step-text:hover {
            border-color: #bdc3c7;
            background: #ecf0f1;
        }
        
        .step-text.editing {
            border-color: #3498db;
            background: white;
        }
        
        /* Edit Buttons */
        .edit-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .edit-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .edit-btn.mic {
            background: #e74c3c;
            color: white;
        }
        
        .edit-btn.mic.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        .edit-btn.send {
            background: #27ae60;
            color: white;
        }
        
        .edit-btn.delete {
            background: #95a5a6;
            color: white;
        }
        
        .edit-btn:hover {
            opacity: 0.8;
        }
        
        /* Add Buttons */
        .add-button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: #ecf0f1;
            border: 2px dashed #bdc3c7;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #7f8c8d;
        }
        
        .add-button:hover {
            background: #d5dbdb;
            border-color: #95a5a6;
        }
        
        /* Category Selection */
        .category-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 20px;
        }
        
        .category-button {
            padding: 40px 20px;
            background: white;
            border: 3px solid #ecf0f1;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            transition: all 0.2s;
        }
        
        .category-button:hover {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        
        /* Save Button */
        .save-button {
            width: 100%;
            padding: 15px;
            margin-top: 30px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .save-button:hover {
            background: #229954;
        }
        
        /* Settings Modal */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .settings-modal {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            font-size: 22px;
            font-weight: bold;
        }

        .settings-close {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .settings-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            margin-bottom: 15px;
            font-family: monospace;
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .settings-button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .settings-button.save {
            background: #27ae60;
            color: white;
        }

        .settings-button.clear {
            background: #95a5a6;
            color: white;
        }

        .settings-info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }

        /* Dictation Display Box */
        .dictation-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 3px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 250;
            min-width: 400px;
            max-width: 600px;
        }

        .dictation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 16px;
        }

        .dictation-pulse {
            width: 12px;
            height: 12px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .dictation-text {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            min-height: 60px;
            font-size: 16px;
            line-height: 1.5;
            color: #2c3e50;
        }

        .dictation-empty {
            color: #95a5a6;
            font-style: italic;
        }

        /* Timer Overlay */
        .timer-overlay {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            border: 3px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            min-width: 250px;
        }
        
        .timer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .timer-close {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .timer-input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .timer-start {
            width: 100%;
            padding: 10px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .timer-display {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            color: #2c3e50;
        }
        
        .timer-alert {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 10px;
        }
        
        /* Messages */
        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            margin: 10px 20px;
            border-radius: 5px;
            text-align: center;
        }
        
        .success-message {
            background: #27ae60;
            color: white;
            padding: 15px;
            margin: 10px 20px;
            border-radius: 5px;
            text-align: center;
        }
        
        .info-message {
            background: #3498db;
            color: white;
            padding: 15px;
            margin: 10px 20px;
            border-radius: 5px;
            text-align: center;
        }
        
        /* Input Field */
        .edit-input {
            width: 100%;
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 4px;
            font-size: 16px;
            font-family: inherit;
        }
        
        .edit-input:focus {
            outline: none;
            border-color: #2980b9;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ============================================
        // GOOGLE CLOUD SPEECH HELPER (Mobile-friendly, no timeout)
        // ============================================

        // Detect if we're on mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Backend URL for Google Cloud Speech
        const currentHost = window.location.hostname;
        const SPEECH_BACKEND_URL = currentHost === 'localhost' || currentHost === '127.0.0.1'
            ? 'http://localhost:3000'
            : `http://${currentHost}:3000`;

        console.log(`üé§ Speech mode: ${isMobile ? 'Google Cloud (mobile)' : 'Web Speech API (desktop)'}`);
        console.log(`üîó Backend URL: ${SPEECH_BACKEND_URL}`);

        // Sample initial recipes
        const CATEGORIES = [
            'Sauces', 'Side Dishes', 'Main Courses', 'Desserts',
            'Appetizers', 'Soups', 'Salads', 'Vegetarian',
            'Vegan', 'Gluten-Free'
        ];

        // Departments
        const DEPARTMENTS = [
            'Poissonerie',
            'Boucherie',
            'Cuisine',
            'Bistro',
            'Pastry'
        ];

        // Master password for unlocking edit mode
        const MASTER_PASSWORD = 'chef2024'; // Change this as needed

        // ============================================
        // DATABASE SETUP
        // ============================================

        // Initialize IndexedDB with Dexie
        const db = new Dexie('KitchenRecipeDB');
        db.version(1).stores({
            recipes: '++id, name, category, portions, updatedAt'
        });

        // ============================================
        // FIREBASE SETUP
        // ============================================

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC2NxcVsQag-qL7VT5mw0DI_0es3hoCAn4",
            authDomain: "smartcookbook-2afe2.firebaseapp.com",
            projectId: "smartcookbook-2afe2",
            storageBucket: "smartcookbook-2afe2.firebasestorage.app",
            messagingSenderId: "1065606137176",
            appId: "1:1065606137176:web:c58caa028e40ba8688112d"
        };

        // Initialize Firebase
        let firebaseApp = null;
        let firestoreDB = null;
        let firebaseAuth = null;

        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            firestoreDB = firebase.firestore();
            firebaseAuth = firebase.auth();
            console.log('‚úÖ Firebase initialized successfully');
        } catch (error) {
            console.warn('‚ö†Ô∏è Firebase not configured yet. App will work offline-only.', error);
        }

        // ============================================
        // GOOGLE CLOUD SPEECH RECORDING HELPER
        // ============================================

        // Google Cloud Speech recording class
        class GoogleCloudRecorder {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.stream = null;
                this.onTranscript = null;
                this.onError = null;
            }

            async start() {
                try {
                    console.log('üé§ [Google Cloud] Requesting microphone...');
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 48000
                        }
                    });

                    const options = { mimeType: 'audio/webm;codecs=opus' };
                    this.mediaRecorder = new MediaRecorder(this.stream, options);
                    this.audioChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = async () => {
                        console.log('üé§ [Google Cloud] Processing audio...');
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm;codecs=opus' });

                        // Convert to base64
                        const base64Audio = await this.blobToBase64(audioBlob);

                        // Send to backend
                        try {
                            const response = await fetch(`${SPEECH_BACKEND_URL}/api/speech/recognize`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    audio: base64Audio,
                                    sampleRate: 48000,
                                    languageCode: 'fr-CA'
                                })
                            });

                            const result = await response.json();

                            if (result.success && this.onTranscript) {
                                console.log(`‚úÖ [Google Cloud] Transcript: "${result.transcript}"`);
                                this.onTranscript(result.transcript, result.confidence);
                            } else if (this.onError) {
                                this.onError(result.error || 'Unknown error');
                            }
                        } catch (error) {
                            console.error('‚ùå [Google Cloud] Error:', error);
                            if (this.onError) {
                                this.onError(error.message);
                            }
                        }
                    };

                    this.mediaRecorder.start();
                    console.log('üé§ [Google Cloud] Recording started');
                    return true;
                } catch (error) {
                    console.error('‚ùå [Google Cloud] Start error:', error);
                    if (this.onError) {
                        this.onError(error.message);
                    }
                    return false;
                }
            }

            stop() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();

                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }
                    console.log('üõë [Google Cloud] Recording stopped');
                }
            }

            async blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }
        }

        // Auto-capitalize first letter of a string
        function capitalizeFirstLetter(str) {
            if (!str || typeof str !== 'string') return str;
            const trimmed = str.trim();
            if (trimmed.length === 0) return trimmed;
            return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
        }

        // Auto-normalize units (gr <-> kg, ml <-> l)
        function normalizeUnit(measurement) {
            if (!measurement || !measurement.value) return measurement;

            const { value, unit, type } = measurement;

            // SOLID: gr ‚Üî kg conversion
            if (type === 'solid') {
                if (unit === 'gr' && value >= 1000) {
                    return {
                        value: value / 1000,
                        unit: 'kg',
                        type: 'solid',
                        displayValue: String((value / 1000).toFixed(2)).replace(/\.?0+$/, '')
                    };
                }
                if (unit === 'kg' && value < 1) {
                    return {
                        value: value * 1000,
                        unit: 'gr',
                        type: 'solid',
                        displayValue: String(Math.round(value * 1000))
                    };
                }
            }

            // LIQUID: ml ‚Üî l conversion
            if (type === 'liquid') {
                if (unit === 'ml' && value >= 1000) {
                    return {
                        value: value / 1000,
                        unit: 'l',
                        type: 'liquid',
                        displayValue: String((value / 1000).toFixed(2)).replace(/\.?0+$/, '')
                    };
                }
                if (unit === 'l' && value < 1) {
                    return {
                        value: value * 1000,
                        unit: 'ml',
                        type: 'liquid',
                        displayValue: String(Math.round(value * 1000))
                    };
                }
            }

            return measurement;
        }

        // ============================================
        // BULK PARSING WITH CLAUDE API
        // ============================================

        // Parse ingredient list using Claude API
        async function parseIngredientListWithClaude(voiceInput, apiKey) {
            console.log('üìù Parsing ingredient list with Claude:', voiceInput);

            const prompt = `Parse this spoken French ingredient list into a JSON array. Each ingredient should have:
- measurement: {value: number, unit: string (gr/kg/ml/cl/dl/l), type: "solid" or "liquid"}
- name: string (capitalized, the ingredient name)
- spec: string (any specifications like "crushed", "diced", "fresh", etc.)

Spoken list: "${voiceInput}"

Return ONLY a valid JSON array, no other text. Example format:
[{"measurement": {"value": 800, "unit": "gr", "type": "solid"}, "name": "Tomates", "spec": "fra√Æches √©cras√©es"}, {"measurement": {"value": 30, "unit": "ml", "type": "liquid"}, "name": "Huile d'olive", "spec": ""}]`;

            try {
                // Use CORS proxy for development (corsproxy.io is free and public)
                const corsProxy = 'https://corsproxy.io/?';
                const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 1024,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                console.log('ü§ñ Claude response:', content);

                // Parse JSON response
                const parsed = JSON.parse(content);

                // Normalize units and add displayValue, capitalize ingredient names
                const ingredients = parsed.map(ing => ({
                    measurement: normalizeUnit({
                        value: ing.measurement.value,
                        unit: ing.measurement.unit,
                        type: ing.measurement.type,
                        displayValue: String(ing.measurement.value)
                    }),
                    name: capitalizeFirstLetter(ing.name),
                    spec: ing.spec || '',
                    grouped: false
                }));

                console.log('üìã Total ingredients parsed:', ingredients.length);
                return ingredients;

            } catch (error) {
                console.error('‚ùå Error parsing with Claude:', error);
                throw error;
            }
        }

        // Parse method steps using Claude API (simpler than ingredients - just split into steps)
        async function parseMethodListWithClaude(voiceInput, apiKey) {
            console.log('üìù Parsing method steps with Claude:', voiceInput);

            const prompt = `Parse this spoken French cooking method into separate logical steps. Return a JSON array of step objects.

Each step should have:
- step: number (sequential, starting from 1)
- instruction: string (the complete instruction including time, temperature, and all details)
- duration: 0 (always 0, durations are in the instruction text)
- temperature: null (always null, temperatures are in the instruction text)

Spoken method: "${voiceInput}"

Split into natural logical steps. Keep ALL details (time, temperature, techniques) in the instruction string. Return ONLY valid JSON.

Example:
[{"step": 1, "instruction": "Chauffer l'huile d'olive dans une grande po√™le √† feu moyen", "duration": 0, "temperature": null}, {"step": 2, "instruction": "Ajouter les oignons hach√©s finement et faire cuire pendant 20 minutes √† feu doux", "duration": 0, "temperature": null}]`;

            try {
                const corsProxy = 'https://corsproxy.io/?';
                const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 2048,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                console.log('ü§ñ Claude response:', content);

                // Parse JSON response
                const parsed = JSON.parse(content);

                console.log('üìã Total method steps parsed:', parsed.length);
                return parsed;

            } catch (error) {
                console.error('‚ùå Error parsing method with Claude:', error);
                throw error;
            }
        }

        // Parse plating steps using Claude API
        async function parsePlatingListWithClaude(voiceInput, apiKey) {
            console.log('üìù Parsing plating steps with Claude:', voiceInput);

            const prompt = `Parse this spoken French plating/packaging instructions into separate logical steps. Return a JSON array of strings (simple text steps).

Spoken plating instructions: "${voiceInput}"

Split into natural logical steps for plating and packaging. Return ONLY a valid JSON array of strings.

Example:
["Dresser dans une assiette creuse", "Garnir avec du persil frais", "Servir imm√©diatement"]`;

            try {
                const corsProxy = 'https://corsproxy.io/?';
                const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 1024,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                console.log('ü§ñ Claude response:', content);

                // Parse JSON response (should be an array of strings)
                const parsed = JSON.parse(content);

                console.log('üìã Total plating steps parsed:', parsed.length);
                return parsed;

            } catch (error) {
                console.error('‚ùå Error parsing plating with Claude:', error);
                throw error;
            }
        }

        // ==================== PDF IMPORT FEATURE START ====================

        // Helper: Convert file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // Remove data:application/pdf;base64, prefix
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Extract text from PDF using PDF.js library
        async function extractTextFromPDF(pdfFile) {
            // Load PDF.js library dynamically if not already loaded
            if (!window.pdfjsLib) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                // Set worker
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }

            const arrayBuffer = await pdfFile.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument(arrayBuffer).promise;

            let fullText = '';

            // Extract text from all pages
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n';
            }

            return fullText;
        }

        // Parse PDF recipe using Claude API
        async function parsePDFRecipeWithClaude(pdfFile, apiKey) {
            console.log('üìÑ Parsing PDF recipe with Claude:', pdfFile.name);

            try {
                // Extract text from PDF
                const pdfText = await extractTextFromPDF(pdfFile);
                console.log('üìù Extracted text from PDF:', pdfText.substring(0, 200) + '...');

                const prompt = `Parse this recipe text (extracted from a PDF) into structured JSON format.

Recipe text:
"""
${pdfText}
"""

Required structure:
{
    "name": "Recipe name",
    "category": "Main Courses",
    "portions": 4,
    "ingredients": [
        {
            "measurement": {"value": 800, "unit": "gr", "type": "solid", "displayValue": "800"},
            "name": "Ingredient name",
            "spec": "specifications like crushed, diced",
            "grouped": false
        }
    ],
    "method": [
        {"step": 1, "instruction": "instruction text", "duration": 0, "temperature": null}
    ],
    "plating": ["plating instruction 1", "plating instruction 2"]
}

Instructions:
- Extract ALL ingredients with measurements
- Convert ALL measurements to metric using ONLY these units: gr, kg, ml, cl, dl, l
- Convert fractions to decimals: "1 1/2" ‚Üí 1.5, "1/2" ‚Üí 0.5, "1/4" ‚Üí 0.25
- Convert imperial to metric: 1 tsp = 5 ml, 1 tbsp = 15 ml, 1 cup = 240 ml, 1 oz = 30 gr, 1 lb = 450 gr
- Determine type: "solid" for dry ingredients (use gr/kg), "liquid" for liquids (use ml/cl/dl/l)
- Use consistent unit abbreviations: gr (NOT gramme/grams), ml (NOT millilitre/milliliter), kg (NOT kilogramme/kilogram), l (NOT litre/liter)
- displayValue should be the decimal number as string (e.g., "1.5" not "1,5")
- Extract method steps in order with full instructions
- Extract any plating/serving/packaging instructions
- If portions not specified, use 4 as default
- Category should be one of: Sauces, Side Dishes, Main Courses, Desserts, Appetizers, Soups, Salads, Vegetarian, Vegan, Gluten-Free
- Return ONLY valid JSON, no other text

Example conversions:
- "1 1/2 tsp" ‚Üí {"value": 7.5, "unit": "ml", "type": "liquid", "displayValue": "7.5"}
- "200 grams" ‚Üí {"value": 200, "unit": "gr", "type": "solid", "displayValue": "200"}
- "1 cup" ‚Üí {"value": 240, "unit": "ml", "type": "liquid", "displayValue": "240"}
- "2,5 kg" ‚Üí {"value": 2.5, "unit": "kg", "type": "solid", "displayValue": "2.5"}`;

                const corsProxy = 'https://corsproxy.io/?';
                const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                // Log rate limit headers for debugging
                console.log('üîç PDF Import Rate Limit Info:');
                console.log('  Requests Limit:', response.headers.get('anthropic-ratelimit-requests-limit'));
                console.log('  Requests Remaining:', response.headers.get('anthropic-ratelimit-requests-remaining'));
                console.log('  Requests Reset:', response.headers.get('anthropic-ratelimit-requests-reset'));
                console.log('  Tokens Limit:', response.headers.get('anthropic-ratelimit-tokens-limit'));
                console.log('  Tokens Remaining:', response.headers.get('anthropic-ratelimit-tokens-remaining'));

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                console.log('ü§ñ Claude response:', content);

                // Extract JSON from response (handle multiple formats)
                let jsonText = content.trim();

                // Try to extract from markdown code blocks
                const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/);
                if (jsonMatch) {
                    jsonText = jsonMatch[1].trim();
                } else {
                    // Try to find JSON object (starts with { and ends with })
                    const jsonStart = content.indexOf('{');
                    const jsonEnd = content.lastIndexOf('}');
                    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                        jsonText = content.substring(jsonStart, jsonEnd + 1);
                    }
                }

                const parsedRecipe = JSON.parse(jsonText);

                // Capitalize recipe name and ingredient names
                const capitalizedIngredients = parsedRecipe.ingredients.map(ing => ({
                    ...ing,
                    name: capitalizeFirstLetter(ing.name)
                }));

                // Add required fields
                const recipe = {
                    ...parsedRecipe,
                    name: capitalizeFirstLetter(parsedRecipe.name),
                    ingredients: capitalizedIngredients,
                    basePortions: parsedRecipe.portions,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    version: 1,
                    syncStatus: 'local'
                };

                console.log('‚úÖ PDF recipe parsed successfully:', recipe.name);
                return recipe;

            } catch (error) {
                console.error('‚ùå Error parsing PDF with Claude:', error);
                throw error;
            }
        }

        // ==================== PDF IMPORT FEATURE END ====================

        // ==================== IMAGE IMPORT FEATURE START ====================

        // Parse image recipe using Claude API (with vision)
        async function parseImageRecipeWithClaude(imageFile, apiKey) {
            console.log('üì∑ Parsing image recipe with Claude:', imageFile.name);

            try {
                // Convert image to base64
                const base64Image = await fileToBase64(imageFile);

                // Determine media type
                let mediaType = 'image/jpeg';
                if (imageFile.type) {
                    mediaType = imageFile.type;
                } else if (imageFile.name.endsWith('.png')) {
                    mediaType = 'image/png';
                } else if (imageFile.name.endsWith('.webp')) {
                    mediaType = 'image/webp';
                }

                const prompt = `Parse this recipe image into structured JSON format.

Required structure:
{
    "name": "Recipe name",
    "category": "Main Courses",
    "portions": 4,
    "ingredients": [
        {
            "measurement": {"value": 800, "unit": "gr", "type": "solid", "displayValue": "800"},
            "name": "Ingredient name",
            "spec": "specifications like crushed, diced",
            "grouped": false
        }
    ],
    "method": [
        {"step": 1, "instruction": "instruction text", "duration": 0, "temperature": null}
    ],
    "plating": ["plating instruction 1", "plating instruction 2"]
}

Instructions:
- Extract ALL ingredients with measurements
- Convert ALL measurements to metric using ONLY these units: gr, kg, ml, cl, dl, l
- Convert fractions to decimals: "1 1/2" ‚Üí 1.5, "1/2" ‚Üí 0.5, "1/4" ‚Üí 0.25
- Convert imperial to metric: 1 tsp = 5 ml, 1 tbsp = 15 ml, 1 cup = 240 ml, 1 oz = 30 gr, 1 lb = 450 gr
- Determine type: "solid" for dry ingredients (use gr/kg), "liquid" for liquids (use ml/cl/dl/l)
- Use consistent unit abbreviations: gr (NOT gramme/grams), ml (NOT millilitre/milliliter), kg (NOT kilogramme/kilogram), l (NOT litre/liter)
- displayValue should be the decimal number as string (e.g., "1.5" not "1,5")
- Extract method steps in order with full instructions
- Extract any plating/serving/packaging instructions
- If portions not specified, use 4 as default
- Category should be one of: Sauces, Side Dishes, Main Courses, Desserts, Appetizers, Soups, Salads, Vegetarian, Vegan, Gluten-Free
- Return ONLY valid JSON, no other text

Example conversions:
- "1 1/2 tsp" ‚Üí {"value": 7.5, "unit": "ml", "type": "liquid", "displayValue": "7.5"}
- "200 grams" ‚Üí {"value": 200, "unit": "gr", "type": "solid", "displayValue": "200"}
- "1 cup" ‚Üí {"value": 240, "unit": "ml", "type": "liquid", "displayValue": "240"}
- "2,5 kg" ‚Üí {"value": 2.5, "unit": "kg", "type": "solid", "displayValue": "2.5"}`;

                const corsProxy = 'https://corsproxy.io/?';
                const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Image
                                    }
                                },
                                {
                                    type: 'text',
                                    text: prompt
                                }
                            ]
                        }]
                    })
                });

                // Log rate limit headers
                console.log('üîç Image Import Rate Limit Info:');
                console.log('  Requests Limit:', response.headers.get('anthropic-ratelimit-requests-limit'));
                console.log('  Requests Remaining:', response.headers.get('anthropic-ratelimit-requests-remaining'));

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                console.log('ü§ñ Claude response:', content);

                // Extract JSON from response (handle multiple formats)
                let jsonText = content.trim();

                // Try to extract from markdown code blocks
                const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/);
                if (jsonMatch) {
                    jsonText = jsonMatch[1].trim();
                } else {
                    // Try to find JSON object (starts with { and ends with })
                    const jsonStart = content.indexOf('{');
                    const jsonEnd = content.lastIndexOf('}');
                    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                        jsonText = content.substring(jsonStart, jsonEnd + 1);
                    }
                }

                const parsedRecipe = JSON.parse(jsonText);

                // Capitalize recipe name and ingredient names
                const capitalizedIngredients = parsedRecipe.ingredients.map(ing => ({
                    ...ing,
                    name: capitalizeFirstLetter(ing.name)
                }));

                // Add required fields
                const recipe = {
                    ...parsedRecipe,
                    name: capitalizeFirstLetter(parsedRecipe.name),
                    ingredients: capitalizedIngredients,
                    basePortions: parsedRecipe.portions,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    version: 1,
                    syncStatus: 'local'
                };

                console.log('‚úÖ Image recipe parsed successfully:', recipe.name);
                return recipe;

            } catch (error) {
                console.error('‚ùå Error parsing image with Claude:', error);
                throw error;
            }
        }

        // ==================== IMAGE IMPORT FEATURE END ====================

        function App() {
            const [page, setPage] = useState('browser');
            const [recipes, setRecipes] = useState([]);
            const [currentRecipe, setCurrentRecipe] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [categoryFilter, setCategoryFilter] = useState('All');
            const [letterFilter, setLetterFilter] = useState('A');
            const [micFlag, setMicFlag] = useState(true);
            const [keypadFlag, setKeypadFlag] = useState(false);
            const [editingCell, setEditingCell] = useState(null);
            const [editValue, setEditValue] = useState('');
            const [originalValue, setOriginalValue] = useState(''); // Track original for cancel
            const [isNewRecipe, setIsNewRecipe] = useState(false);
            const [showTimer, setShowTimer] = useState(false);
            const [timerValue, setTimerValue] = useState('');
            const [activeTimers, setActiveTimers] = useState([]);
            const [errorMessage, setErrorMessage] = useState('');
            const [infoMessage, setInfoMessage] = useState('');
            const [voiceActive, setVoiceActive] = useState(false);
            const [speechSupported, setSpeechSupported] = useState(true);
            const [editingSearch, setEditingSearch] = useState(false);
            const [searchVoiceActive, setSearchVoiceActive] = useState(false);
            const [bulkDictating, setBulkDictating] = useState(false);
            const [bulkTranscript, setBulkTranscript] = useState('');
            const [bulkDictatingMethod, setBulkDictatingMethod] = useState(false);
            const [bulkMethodTranscript, setBulkMethodTranscript] = useState('');
            const [bulkDictatingPlating, setBulkDictatingPlating] = useState(false);
            const [bulkPlatingTranscript, setBulkPlatingTranscript] = useState('');
            const [importingPDF, setImportingPDF] = useState(false);
            const [previewRecipe, setPreviewRecipe] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [claudeApiKey, setClaudeApiKey] = useState('');
            const [tempApiKey, setTempApiKey] = useState('');

            // Lock/Unlock and Department state
            const [isUnlocked, setIsUnlocked] = useState(true); // TESTING: Edit lock disabled
            const [showPasswordModal, setShowPasswordModal] = useState(false);
            const [passwordInput, setPasswordInput] = useState('');
            const [currentDepartment, setCurrentDepartment] = useState(
                localStorage.getItem('currentDepartment') || 'Cuisine'
            );
            const [showDepartmentModal, setShowDepartmentModal] = useState(false);

            // Marketing Generator state
            const [showMarketingModal, setShowMarketingModal] = useState(false);
            const [marketingContext, setMarketingContext] = useState('Daily Special');
            const [marketingTone, setMarketingTone] = useState('Casual & Friendly');
            const [marketingPlatform, setMarketingPlatform] = useState('Instagram');
            const [marketingResults, setMarketingResults] = useState([]);
            const [generatingMarketing, setGeneratingMarketing] = useState(false);
            const [marketingImage, setMarketingImage] = useState(null);
            const [marketingImageUrl, setMarketingImageUrl] = useState('');

            // Dropdown menu state
            const [showDropdown, setShowDropdown] = useState(false);

            const inputRef = useRef(null);
            const recognitionRef = useRef(null);
            const bulkTimerRef = useRef(null);
            const bulkSilenceTimerRef = useRef(null); // Timer for detecting silence during bulk dictation
            const bulkShouldParse = useRef(false); // Flag to trigger parsing when recognition ends
            const silenceTimerRef = useRef(null);
            const micTimerRef = useRef(null); // Timer for auto-stopping mic after inactivity
            const searchMicTimerRef = useRef(null); // Timer for auto-stopping search mic
            const googleCloudRecorderRef = useRef(null); // Google Cloud Speech recorder for mobile

            const MIC_AUTO_STOP_DURATION = 10000; // 10 seconds - auto-stop if no field activity
            const BULK_SILENCE_DURATION = 5000; // 5 seconds - auto-stop bulk dictation after silence

            // Load Claude API key from localStorage on startup
            useEffect(() => {
                const savedKey = localStorage.getItem('claudeApiKey');
                if (savedKey) {
                    setClaudeApiKey(savedKey);
                    console.log('‚úÖ Loaded Claude API key from localStorage');
                }
            }, []);

            // Load recipes from cloud on startup (with department filter)
            useEffect(() => {
                if (firestoreDB) {
                    loadRecipesFromCloud();
                }
            }, [currentDepartment]); // Reload when department changes

            // Lock/Unlock functions
            const handleUnlock = () => {
                if (passwordInput === MASTER_PASSWORD) {
                    setIsUnlocked(true);
                    setShowPasswordModal(false);
                    setPasswordInput('');
                    setInfoMessage('üîì Unlocked! Edit mode enabled.');
                    setTimeout(() => setInfoMessage(''), 3000);

                    // Auto-lock after 30 minutes
                    setTimeout(() => {
                        setIsUnlocked(false);
                        setInfoMessage('üîí Auto-locked after inactivity');
                        setTimeout(() => setInfoMessage(''), 3000);
                    }, 30 * 60 * 1000);
                } else {
                    setErrorMessage('‚ùå Incorrect password');
                    setPasswordInput('');
                    setTimeout(() => setErrorMessage(''), 3000);
                }
            };

            const handleLock = () => {
                setIsUnlocked(false);
                setInfoMessage('üîí Locked. Viewing mode only.');
                setTimeout(() => setInfoMessage(''), 3000);
            };

            const handleSwitchDepartment = (newDept) => {
                setCurrentDepartment(newDept);
                localStorage.setItem('currentDepartment', newDept);
                setShowDepartmentModal(false);
                setInfoMessage(`üè¢ Switched to ${newDept}`);
                setTimeout(() => setInfoMessage(''), 3000);

                // Reload recipes for new department
                loadRecipesFromCloud();
            };

            // ============================================
            // MARKETING GENERATOR
            // ============================================

            const generateMarketingCopy = async () => {
                if (!claudeApiKey) {
                    setErrorMessage('‚ùå Claude API key not set. Go to Settings to add your API key.');
                    setTimeout(() => setErrorMessage(''), 5000);
                    return;
                }

                setGeneratingMarketing(true);
                setMarketingResults([]);

                try {
                    // Prepare recipe details
                    const ingredientsList = currentRecipe.ingredients
                        .map(ing => `${ing.measurement?.value || ''} ${ing.measurement?.unit || ''} ${ing.name}`.trim())
                        .join(', ');

                    const methodSteps = currentRecipe.method
                        .map((step, idx) => `${idx + 1}. ${typeof step === 'string' ? step : step.instruction}`)
                        .join('\n');

                    // Claude API prompt
                    const prompt = `You are an expert restaurant marketing copywriter and social media strategist.

RECIPE TO PROMOTE:
Name: ${currentRecipe.name}
Category: ${currentRecipe.category || 'N/A'}
Department: ${currentRecipe.department || currentDepartment}
Ingredients: ${ingredientsList}
Method: ${methodSteps}

MARKETING PARAMETERS:
Context/Occasion: ${marketingContext}
Tone & Style: ${marketingTone}
Platform: ${marketingPlatform}

TASK:
Generate 3 engaging social media posts that:
1. Hook readers with an attention-grabbing opening line
2. Describe the dish in a mouth-watering, vivid way
3. Highlight what makes this dish special (premium ingredients, unique preparation, etc.)
4. Include appropriate emojis for visual appeal
5. Add a clear call-to-action
6. Create 10-15 relevant, high-engagement hashtags
7. Suggest a free stock photo URL from Unsplash that matches this dish

Each variation should have a different approach/angle while maintaining the specified tone.

FORMAT YOUR RESPONSE AS VALID JSON:
{
    "imageUrl": "https://images.unsplash.com/photo-[ID]?w=800&q=80",
    "imageSearchTerm": "professional food photography of [dish name]",
    "variations": [
        {
            "title": "Variation 1 - [Brief Style Description]",
            "copy": "The complete social media post text with emojis...",
            "hashtags": "#hashtag1 #hashtag2 #hashtag3 ..."
        },
        {
            "title": "Variation 2 - [Brief Style Description]",
            "copy": "The complete social media post text with emojis...",
            "hashtags": "#hashtag1 #hashtag2 #hashtag3 ..."
        },
        {
            "title": "Variation 3 - [Brief Style Description]",
            "copy": "The complete social media post text with emojis...",
            "hashtags": "#hashtag1 #hashtag2 #hashtag3 ..."
        }
    ]
}

IMPORTANT: Return ONLY the JSON object, no additional text before or after.`;

                    // Call Claude API via CORS proxy
                    const corsProxy = 'https://corsproxy.io/?';
                    const apiUrl = corsProxy + encodeURIComponent('https://api.anthropic.com/v1/messages');

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': claudeApiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-haiku-20240307',
                            max_tokens: 4096,
                            messages: [{
                                role: 'user',
                                content: prompt
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        throw new Error(`Claude API error: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();
                    const content = data.content[0].text;

                    console.log('ü§ñ Claude response:', content);

                    // Extract JSON from response
                    let jsonText = content.trim();
                    const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/);
                    if (jsonMatch) {
                        jsonText = jsonMatch[1].trim();
                    } else {
                        const jsonStart = content.indexOf('{');
                        const jsonEnd = content.lastIndexOf('}');
                        if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                            jsonText = content.substring(jsonStart, jsonEnd + 1);
                        }
                    }

                    const parsedResult = JSON.parse(jsonText);
                    setMarketingResults(parsedResult.variations || []);

                    // Fetch AI-suggested image from Pexels if no custom image uploaded
                    if (!marketingImage) {
                        console.log('üì∏ Attempting to fetch image from Pexels...');
                        try {
                            // Use Pexels API - free, high-quality food images, commercial use allowed
                            const searchQuery = encodeURIComponent(currentRecipe.name + ' food');
                            const pexelsApiKey = 'gKUea3J0xfKjP9CYuKhxL3Q3f9V3UME38ZH9wRfYqjAKJPJ5w7Xr0kxN'; // Free tier: 200 requests/hour

                            console.log('üì∏ Searching Pexels for:', currentRecipe.name + ' food');
                            const pexelsResponse = await fetch(`https://api.pexels.com/v1/search?query=${searchQuery}&per_page=5&orientation=landscape`, {
                                headers: {
                                    'Authorization': pexelsApiKey
                                }
                            });

                            console.log('üì∏ Pexels response status:', pexelsResponse.status);

                            if (pexelsResponse.ok) {
                                const pexelsData = await pexelsResponse.json();
                                console.log('üì∏ Pexels data:', pexelsData);

                                if (pexelsData.photos && pexelsData.photos.length > 0) {
                                    // Get random image from results
                                    const randomIndex = Math.floor(Math.random() * pexelsData.photos.length);
                                    const foodImageUrl = pexelsData.photos[randomIndex].src.large;
                                    console.log('üì∏ ‚úÖ Found Pexels image for:', currentRecipe.name, '‚Üí', foodImageUrl);
                                    setMarketingImageUrl(foodImageUrl);
                                } else {
                                    console.log('‚ö†Ô∏è No Pexels images found for specific dish, trying generic food...');
                                    // Fallback to generic food search
                                    const fallbackResponse = await fetch('https://api.pexels.com/v1/search?query=gourmet+food&per_page=10', {
                                        headers: { 'Authorization': pexelsApiKey }
                                    });
                                    const fallbackData = await fallbackResponse.json();
                                    console.log('üì∏ Fallback data:', fallbackData);

                                    if (fallbackData.photos && fallbackData.photos.length > 0) {
                                        const randomIndex = Math.floor(Math.random() * fallbackData.photos.length);
                                        const genericImageUrl = fallbackData.photos[randomIndex].src.large;
                                        console.log('üì∏ ‚úÖ Using generic food image:', genericImageUrl);
                                        setMarketingImageUrl(genericImageUrl);
                                    }
                                }
                            } else {
                                console.error('‚ùå Pexels API error:', pexelsResponse.status, pexelsResponse.statusText);
                                const errorText = await pexelsResponse.text();
                                console.error('‚ùå Error details:', errorText);
                            }
                        } catch (error) {
                            console.error('‚ùå Error fetching Pexels image:', error);
                        }
                    }

                    setInfoMessage('‚úÖ Marketing copy generated!');
                    setTimeout(() => setInfoMessage(''), 3000);

                } catch (error) {
                    console.error('‚ùå Error generating marketing copy:', error);
                    setErrorMessage(`Failed to generate marketing copy: ${error.message}`);
                    setTimeout(() => setErrorMessage(''), 5000);
                } finally {
                    setGeneratingMarketing(false);
                }
            };

            // ============================================
            // CLOUD SYNC FUNCTIONS (Shared Library)
            // ============================================

            // Sync recipe to Firestore (shared collection)
            const syncRecipeToCloud = async (recipe) => {
                if (!firestoreDB) return;

                try {
                    const recipeToSync = {
                        ...recipe,
                        department: recipe.department || currentDepartment,
                        syncedAt: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    // Remove targetPortions before syncing
                    const { targetPortions, ...recipeWithoutTarget } = recipeToSync;

                    await firestoreDB
                        .collection('recipes')
                        .doc(String(recipe.id))
                        .set(recipeWithoutTarget, { merge: true });

                    console.log('‚òÅÔ∏è Synced recipe to cloud:', recipe.name);
                } catch (error) {
                    console.error('‚ùå Error syncing recipe to cloud:', error);
                }
            };

            // Delete recipe from Firestore (shared collection)
            const deleteRecipeFromCloud = async (recipeId) => {
                if (!firestoreDB) return;

                try {
                    await firestoreDB
                        .collection('recipes')
                        .doc(String(recipeId))
                        .delete();

                    console.log('‚òÅÔ∏è Deleted recipe from cloud:', recipeId);
                } catch (error) {
                    console.error('‚ùå Error deleting recipe from cloud:', error);
                }
            };

            // Load recipes from Firestore (shared collection with department filter)
            const loadRecipesFromCloud = async () => {
                if (!firestoreDB) return;

                try {
                    console.log('‚òÅÔ∏è Loading recipes from cloud for department:', currentDepartment);

                    const snapshot = await firestoreDB
                        .collection('recipes')
                        .where('department', '==', currentDepartment)
                        .get();

                    const cloudRecipes = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));

                    console.log('‚òÅÔ∏è Loaded', cloudRecipes.length, 'recipe(s) from cloud');

                    // Save to local IndexedDB
                    if (cloudRecipes.length > 0) {
                        await db.recipes.clear(); // Clear old data
                        await db.recipes.bulkAdd(cloudRecipes);
                    }

                    // Update state
                    setRecipes(cloudRecipes);

                    if (cloudRecipes.length > 0) {
                        setInfoMessage(`‚úÖ Loaded ${cloudRecipes.length} recipe(s) from ${currentDepartment}`);
                        setTimeout(() => setInfoMessage(''), 3000);
                    }

                } catch (error) {
                    console.error('‚ùå Error loading recipes from cloud:', error);
                    setErrorMessage('Failed to load recipes from cloud: ' + error.message);
                }
            };


            // Load recipes from database on startup
            useEffect(() => {
                async function loadRecipesFromDB() {
                    try {
                        // Load existing recipes from database
                        const loaded = await db.recipes.toArray();

                        if (loaded.length === 0) {
                            // Empty database - start clean
                            console.log('üìÇ Database is empty - ready for user to create recipes');
                            setRecipes([]);
                        } else {
                            // Migrate recipes: remove targetPortions, ensure grouped field exists
                            const migratedRecipes = loaded.map(recipe => {
                                const { targetPortions, ...rest } = recipe;

                                // Ensure all ingredients have grouped field (default false)
                                const migratedIngredients = (rest.ingredients || []).map(ing => ({
                                    ...ing,
                                    grouped: ing.grouped !== undefined ? ing.grouped : false
                                }));

                                return {
                                    ...rest,
                                    ingredients: migratedIngredients
                                };
                            });

                            setRecipes(migratedRecipes);
                            console.log('‚úÖ Loaded', migratedRecipes.length, 'recipe(s) from database');
                        }
                    } catch (error) {
                        console.error('‚ùå Error loading recipes from database:', error);
                        setErrorMessage('Failed to load recipes from database: ' + error.message);
                    }
                }

                loadRecipesFromDB();
            }, []); // Run only once on mount

            // Auto-save recipes to database AND cloud when they change
            useEffect(() => {
                async function saveRecipesToDB() {
                    if (recipes.length > 0) {
                        try {
                            // Remove targetPortions before saving (it's display-only, should reset on load)
                            const recipesToSave = recipes.map(r => {
                                const { targetPortions, ...recipeWithoutTarget } = r;
                                return {
                                    ...recipeWithoutTarget,
                                    updatedAt: Date.now()
                                };
                            });

                            // Save to local database (always)
                            await db.recipes.bulkPut(recipesToSave);
                            console.log('üíæ Auto-saved', recipes.length, 'recipe(s) to database');

                            // Also sync to cloud (shared collection)
                            if (firestoreDB) {
                                // Sync all recipes to cloud (batch operation)
                                const batch = firestoreDB.batch();

                                recipesToSave.forEach(recipe => {
                                    const docRef = firestoreDB
                                        .collection('recipes')
                                        .doc(String(recipe.id));

                                    batch.set(docRef, {
                                        ...recipe,
                                        department: recipe.department || currentDepartment,
                                        syncedAt: firebase.firestore.FieldValue.serverTimestamp()
                                    }, { merge: true });
                                });

                                await batch.commit();
                                console.log('‚òÅÔ∏è Auto-synced to cloud');
                            }
                        } catch (error) {
                            console.error('‚ùå Error saving recipes:', error);
                        }
                    }
                }

                saveRecipesToDB();
            }, [recipes]); // Run whenever recipes change

            useEffect(() => {
                if (editingCell && inputRef.current) {
                    inputRef.current.focus();
                }
            }, [editingCell]);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (showDropdown && !event.target.closest('.dropdown')) {
                        setShowDropdown(false);
                    }
                };

                document.addEventListener('click', handleClickOutside);
                return () => document.removeEventListener('click', handleClickOutside);
            }, [showDropdown]);

            // Initialize Speech Recognition
            useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    setSpeechSupported(false);
                    setInfoMessage('Speech recognition not supported in this browser. Please use Chrome or Edge for voice input. Keyboard input still available!');
                    return;
                }

                const recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'fr-CA';
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let hasAnyTranscript = false;

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        }
                        // Track if ANY speech is happening (interim or final)
                        if (transcript) {
                            hasAnyTranscript = true;
                        }
                    }

                    // Reset timers on ANY speech activity (even interim results)
                    if (hasAnyTranscript) {
                        // Reset bulk ingredient dictation timer
                        setBulkDictating(currentBulkDictating => {
                            if (currentBulkDictating) {
                                if (bulkSilenceTimerRef.current) {
                                    clearTimeout(bulkSilenceTimerRef.current);
                                }
                                bulkSilenceTimerRef.current = setTimeout(() => {
                                    console.log('‚è∏Ô∏è 5 seconds of silence - auto-stopping bulk dictation');
                                    bulkShouldParse.current = true;
                                    if (recognitionRef.current) {
                                        recognitionRef.current.stop();
                                    }
                                }, BULK_SILENCE_DURATION);
                            }
                            return currentBulkDictating;
                        });

                        // Reset bulk method dictation timer
                        setBulkDictatingMethod(currentBulkDictatingMethod => {
                            if (currentBulkDictatingMethod) {
                                if (bulkSilenceTimerRef.current) {
                                    clearTimeout(bulkSilenceTimerRef.current);
                                }
                                bulkSilenceTimerRef.current = setTimeout(() => {
                                    console.log('‚è∏Ô∏è 5 seconds of silence - auto-stopping method dictation');
                                    bulkShouldParse.current = true;
                                    if (recognitionRef.current) {
                                        recognitionRef.current.stop();
                                    }
                                }, BULK_SILENCE_DURATION);
                            }
                            return currentBulkDictatingMethod;
                        });

                        // Reset bulk plating dictation timer
                        setBulkDictatingPlating(currentBulkDictatingPlating => {
                            if (currentBulkDictatingPlating) {
                                if (bulkSilenceTimerRef.current) {
                                    clearTimeout(bulkSilenceTimerRef.current);
                                }
                                bulkSilenceTimerRef.current = setTimeout(() => {
                                    console.log('‚è∏Ô∏è 5 seconds of silence - auto-stopping plating dictation');
                                    bulkShouldParse.current = true;
                                    if (recognitionRef.current) {
                                        recognitionRef.current.stop();
                                    }
                                }, BULK_SILENCE_DURATION);
                            }
                            return currentBulkDictatingPlating;
                        });
                    }

                    // Update transcripts only with FINAL results
                    if (finalTranscript) {
                        // Check which mode we're in
                        setBulkDictating(currentBulkDictating => {
                            if (currentBulkDictating) {
                                // Bulk ingredient dictation mode - accumulate transcript
                                setBulkTranscript(prev => {
                                    if (prev === '') {
                                        return finalTranscript.trim();
                                    } else {
                                        return (prev + ' ' + finalTranscript).trim();
                                    }
                                });
                            }
                            return currentBulkDictating;
                        });

                        setBulkDictatingMethod(currentBulkDictatingMethod => {
                            if (currentBulkDictatingMethod) {
                                // Bulk method dictation mode - accumulate transcript
                                setBulkMethodTranscript(prev => {
                                    if (prev === '') {
                                        return finalTranscript.trim();
                                    } else {
                                        return (prev + ' ' + finalTranscript).trim();
                                    }
                                });
                            }
                            return currentBulkDictatingMethod;
                        });

                        setBulkDictatingPlating(currentBulkDictatingPlating => {
                            if (currentBulkDictatingPlating) {
                                // Bulk plating dictation mode - accumulate transcript
                                setBulkPlatingTranscript(prev => {
                                    if (prev === '') {
                                        return finalTranscript.trim();
                                    } else {
                                        return (prev + ' ' + finalTranscript).trim();
                                    }
                                });
                            }
                            return currentBulkDictatingPlating;
                        });

                        // Only update edit fields if NOT in bulk dictation mode
                        setBulkDictating(currentBulk => {
                            setBulkDictatingMethod(currentMethod => {
                                setBulkDictatingPlating(currentPlating => {
                                    // Check if we're in any bulk mode
                                    const inBulkMode = currentBulk || currentMethod || currentPlating;

                                    if (!inBulkMode) {
                                        setEditingCell(currentEditingCell => {
                                            if (currentEditingCell) {
                                                // Edit mode - update editValue
                                                setEditValue(prev => {
                                                    if (prev === '') {
                                                        return finalTranscript.trim();
                                                    } else {
                                                        return (prev + ' ' + finalTranscript).trim();
                                                    }
                                                });
                                            }
                                            return currentEditingCell;
                                        });
                                    }

                                    return currentPlating;
                                });
                                return currentMethod;
                            });
                            return currentBulk;
                        });

                        setSearchVoiceActive(currentSearchVoiceActive => {
                            if (currentSearchVoiceActive) {
                                // Search mode - update searchQuery
                                setSearchQuery(prev => {
                                    if (prev === '') {
                                        return finalTranscript.trim();
                                    } else {
                                        return (prev + ' ' + finalTranscript).trim();
                                    }
                                });
                            }
                            return currentSearchVoiceActive;
                        });
                    }

                    if (silenceTimerRef.current) {
                        clearTimeout(silenceTimerRef.current);
                    }

                    silenceTimerRef.current = setTimeout(() => {
                        console.log('‚è∏Ô∏è 2 seconds of silence - ready to send');
                    }, 2000);
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);

                    if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        setErrorMessage('üé§ Microphone permission denied. Please allow microphone access in your browser settings and reload the page.');
                        setVoiceActive(false);
                    } else if (event.error === 'no-speech') {
                        console.log('No speech detected, still listening...');
                    } else if (event.error === 'network') {
                        setErrorMessage('Network error. Speech recognition requires internet connection.');
                        setVoiceActive(false);
                    } else if (event.error === 'aborted') {
                        console.log('Speech recognition aborted');
                    } else {
                        console.log('Speech error:', event.error);
                    }
                };

                recognition.onstart = () => {
                    console.log('üé§ Speech recognition started');

                    // Start initial silence timer AFTER recognition actually starts (after mic permission granted)
                    setBulkDictating(currentBulkDictating => {
                        if (currentBulkDictating) {
                            bulkSilenceTimerRef.current = setTimeout(() => {
                                console.log('‚è∏Ô∏è 5 seconds of initial silence - stopping');
                                bulkShouldParse.current = true;
                                if (recognitionRef.current) {
                                    recognitionRef.current.stop();
                                }
                            }, BULK_SILENCE_DURATION);
                        }
                        return currentBulkDictating;
                    });

                    setBulkDictatingMethod(currentBulkDictatingMethod => {
                        if (currentBulkDictatingMethod) {
                            bulkSilenceTimerRef.current = setTimeout(() => {
                                console.log('‚è∏Ô∏è 5 seconds of initial silence - stopping');
                                bulkShouldParse.current = true;
                                if (recognitionRef.current) {
                                    recognitionRef.current.stop();
                                }
                            }, BULK_SILENCE_DURATION);
                        }
                        return currentBulkDictatingMethod;
                    });

                    setBulkDictatingPlating(currentBulkDictatingPlating => {
                        if (currentBulkDictatingPlating) {
                            bulkSilenceTimerRef.current = setTimeout(() => {
                                console.log('‚è∏Ô∏è 5 seconds of initial silence - stopping');
                                bulkShouldParse.current = true;
                                if (recognitionRef.current) {
                                    recognitionRef.current.stop();
                                }
                            }, BULK_SILENCE_DURATION);
                        }
                        return currentBulkDictatingPlating;
                    });
                };

                recognition.onend = () => {
                    console.log('üõë Speech recognition ended');

                    // Check if we should trigger parsing
                    if (bulkShouldParse.current) {
                        console.log('üìã Bulk dictation ended via silence, triggering parse...');
                        bulkShouldParse.current = false;
                        // Small delay to ensure transcript is fully captured
                        setTimeout(() => {
                            // Check which mode to stop
                            setBulkDictating(current => {
                                if (current) stopBulkDictation();
                                return current;
                            });
                            setBulkDictatingMethod(current => {
                                if (current) stopBulkMethodDictation();
                                return current;
                            });
                            setBulkDictatingPlating(current => {
                                if (current) stopBulkPlatingDictation();
                                return current;
                            });
                        }, 100);
                    }
                };

                recognitionRef.current = recognition;

                return () => {
                    if (recognitionRef.current) {
                        try {
                            recognitionRef.current.stop();
                        } catch (e) {
                            console.log('Cleanup error:', e.message);
                        }
                    }
                    if (silenceTimerRef.current) {
                        clearTimeout(silenceTimerRef.current);
                    }
                    if (micTimerRef.current) {
                        clearTimeout(micTimerRef.current);
                    }
                    if (searchMicTimerRef.current) {
                        clearTimeout(searchMicTimerRef.current);
                    }
                    if (bulkSilenceTimerRef.current) {
                        clearTimeout(bulkSilenceTimerRef.current);
                    }
                };
            }, []); // ‚Üê FIXED: Empty array means run only once on mount

            const handleVoiceInput = () => {
                if (!speechSupported) {
                    setErrorMessage('Speech recognition not supported in this browser. Please use Chrome or Edge.');
                    return;
                }

                if (!voiceActive) {
                    setVoiceActive(true);
                    setErrorMessage('');
                    setInfoMessage('üé§ Listening... Speak now!');
                    
                    try {
                        recognitionRef.current.start();
                        console.log('üé§ Voice recognition started - USB mic will be used');
                        
                        setTimeout(() => setInfoMessage(''), 3000);
                    } catch (e) {
                        console.log('Recognition start error:', e.message);
                        if (e.message.includes('already started')) {
                            console.log('Recognition already active');
                        }
                    }
                } else {
                    setVoiceActive(false);
                    if (recognitionRef.current) {
                        recognitionRef.current.stop();
                    }
                    console.log('üõë Voice recognition stopped');
                }
            };
            
            const resetMicTimer = () => {
                // Clear existing timer if any
                if (micTimerRef.current) {
                    clearTimeout(micTimerRef.current);
                }

                // Start new 10-second timer
                micTimerRef.current = setTimeout(() => {
                    if (voiceActive && recognitionRef.current) {
                        recognitionRef.current.stop();
                        setVoiceActive(false);
                        console.log('‚è±Ô∏è Mic auto-stopped after 10 seconds of inactivity');
                    }
                }, MIC_AUTO_STOP_DURATION);
            };

            const resetSearchMicTimer = () => {
                // Clear existing timer if any
                if (searchMicTimerRef.current) {
                    clearTimeout(searchMicTimerRef.current);
                }

                // Start new 10-second timer for search
                searchMicTimerRef.current = setTimeout(() => {
                    if (searchVoiceActive && recognitionRef.current) {
                        recognitionRef.current.stop();
                        setSearchVoiceActive(false);
                        setVoiceActive(false);
                        console.log('‚è±Ô∏è Search mic auto-stopped after 10 seconds of inactivity');
                    }
                }, MIC_AUTO_STOP_DURATION);
            };

            const handleSearchClick = () => {
                // Stop edit voice if active
                if (editingCell) {
                    handleSend(true); // Auto-save current edit
                }
                if (micTimerRef.current) {
                    clearTimeout(micTimerRef.current);
                }

                // Auto-start microphone if mic flag is ON and not already active
                if (micFlag && !searchVoiceActive) {
                    // Use the same logic as handleSearchVoiceToggle
                    handleSearchVoiceToggle();
                }
            };

            const handleSearchVoiceToggle = async () => {
                if (!searchVoiceActive) {
                    // Start search voice
                    setSearchVoiceActive(true);
                    setVoiceActive(true);
                    setErrorMessage('');
                    setInfoMessage('üé§ Listening for search... Speak now!');

                    // Use Google Cloud on mobile, Web Speech API on desktop
                    if (isMobile) {
                        console.log('üì± Using Google Cloud Speech (mobile mode)');

                        // Initialize Google Cloud recorder if not already created
                        if (!googleCloudRecorderRef.current) {
                            googleCloudRecorderRef.current = new GoogleCloudRecorder();

                            // Set up callbacks
                            googleCloudRecorderRef.current.onTranscript = (transcript, confidence) => {
                                console.log(`‚úÖ Transcript received: "${transcript}" (${(confidence * 100).toFixed(1)}%)`);
                                setSearchQuery(transcript);
                                setSearchVoiceActive(false);
                                setVoiceActive(false);
                                setInfoMessage(`‚úÖ Heard: "${transcript}"`);
                                setTimeout(() => setInfoMessage(''), 3000);
                            };

                            googleCloudRecorderRef.current.onError = (error) => {
                                console.error('‚ùå Google Cloud error:', error);
                                setErrorMessage(`Speech error: ${error}`);
                                setSearchVoiceActive(false);
                                setVoiceActive(false);
                            };
                        }

                        // Start recording
                        const started = await googleCloudRecorderRef.current.start();
                        if (!started) {
                            setSearchVoiceActive(false);
                            setVoiceActive(false);
                            setErrorMessage('Could not start microphone');
                        }

                    } else {
                        // Desktop: use Web Speech API
                        console.log('üíª Using Web Speech API (desktop mode)');

                        if (!speechSupported) {
                            setErrorMessage('Speech recognition not supported in this browser. Please use Chrome or Edge.');
                            setSearchVoiceActive(false);
                            setVoiceActive(false);
                            return;
                        }

                        try {
                            recognitionRef.current.start();
                            resetSearchMicTimer();
                            console.log('üé§ Search voice recognition started');
                            setTimeout(() => setInfoMessage(''), 3000);
                        } catch (e) {
                            if (e.message.includes('already started')) {
                                resetSearchMicTimer();
                            } else {
                                setErrorMessage('Could not start voice recognition: ' + e.message);
                                setSearchVoiceActive(false);
                                setVoiceActive(false);
                            }
                        }
                    }
                } else {
                    // Stop search voice
                    setSearchVoiceActive(false);
                    setVoiceActive(false);

                    if (isMobile && googleCloudRecorderRef.current) {
                        googleCloudRecorderRef.current.stop();
                        console.log('üõë Google Cloud recording stopped');
                    } else if (recognitionRef.current) {
                        recognitionRef.current.stop();
                        console.log('üõë Web Speech recognition stopped');
                    }

                    if (searchMicTimerRef.current) {
                        clearTimeout(searchMicTimerRef.current);
                    }
                }
            };

            const handleSearchSend = () => {
                // Stop search voice if active (both Web Speech and Google Cloud)
                if (searchVoiceActive) {
                    if (isMobile && googleCloudRecorderRef.current) {
                        googleCloudRecorderRef.current.stop();
                        console.log('üõë Google Cloud recording stopped (Send button)');
                    } else if (recognitionRef.current) {
                        recognitionRef.current.stop();
                        console.log('üõë Web Speech recognition stopped (Send button)');
                    }
                    setSearchVoiceActive(false);
                    setVoiceActive(false);
                }

                // Clear search mic timer
                if (searchMicTimerRef.current) {
                    clearTimeout(searchMicTimerRef.current);
                    searchMicTimerRef.current = null;
                }

                console.log('üîç Search executed with query:', searchQuery);
            };

            const handleSend = (isAutoSave = false) => {
                // Always stop voice when saving
                if (voiceActive && recognitionRef.current) {
                    recognitionRef.current.stop();
                    setVoiceActive(false);
                }
                
                // Clear mic timer
                if (micTimerRef.current) {
                    clearTimeout(micTimerRef.current);
                    micTimerRef.current = null;
                }

                if (editingCell) {
                    const { type, recipeId, index, field } = editingCell;

                    setRecipes(prev => {
                        const updated = prev.map(recipe => {
                            if (recipe.id === recipeId) {
                                let updatedRecipe = recipe;

                                if (type === 'name') {
                                    // Auto-capitalize first letter
                                    const capitalizedName = capitalizeFirstLetter(editValue);

                                    // Check for duplicate names (skip if empty)
                                    if (capitalizedName.trim()) {
                                        const duplicate = prev.find(r => r.id !== recipeId && r.name === capitalizedName);
                                        if (duplicate) {
                                            setErrorMessage('Recipe name already exists, delete existing one before if trying to replace. Please choose a different name.');
                                            return recipe;
                                        }
                                    }
                                    updatedRecipe = { ...recipe, name: capitalizedName };
                                } else if (type === 'basePortions') {
                                    // Update base portions WITHOUT scaling ingredients
                                    const newBasePortions = parseInt(editValue) || 1;
                                    updatedRecipe = {
                                        ...recipe,
                                        basePortions: newBasePortions,
                                        // Reset targetPortions to match new basePortions
                                        targetPortions: newBasePortions,
                                        // Keep portions in sync for backward compatibility
                                        portions: newBasePortions
                                    };
                                } else if (type === 'targetPortions') {
                                    // Update target portions WITHOUT modifying ingredients
                                    // Scaling will happen on-the-fly in the display layer
                                    const newTargetPortions = parseInt(editValue) || 1;
                                    updatedRecipe = {
                                        ...recipe,
                                        targetPortions: newTargetPortions,
                                        portions: newTargetPortions // Keep for backward compatibility
                                    };
                                } else if (type === 'ingredient') {
                                    const newIngredients = [...recipe.ingredients];

                                    if (field === 'measurement') {
                                        // Parse measurement string like "800 gr" or "1.5 l"
                                        const match = editValue.trim().match(/^([\d.]+)\s*(\w+)$/);
                                        if (match) {
                                            const value = parseFloat(match[1]);
                                            const unit = match[2].toLowerCase();
                                            const liquidUnits = ['ml', 'cl', 'dl', 'l'];
                                            const type = liquidUnits.includes(unit) ? 'liquid' : 'solid';

                                            newIngredients[index] = {
                                                ...newIngredients[index],
                                                measurement: normalizeUnit({
                                                    value: value,
                                                    unit: unit,
                                                    type: type,
                                                    displayValue: String(value)
                                                })
                                            };
                                        } else if (editValue.trim() === '') {
                                            // Clear measurement
                                            newIngredients[index] = {
                                                ...newIngredients[index],
                                                measurement: { value: 0, unit: '', type: 'solid', displayValue: '' }
                                            };
                                        }
                                    } else {
                                        // Other fields (name, spec)
                                        // Auto-capitalize ingredient name
                                        const valueToSave = field === 'name' ? capitalizeFirstLetter(editValue) : editValue;
                                        newIngredients[index] = { ...newIngredients[index], [field]: valueToSave };
                                    }

                                    updatedRecipe = { ...recipe, ingredients: newIngredients };
                                } else if (type === 'method') {
                                    const newMethod = [...recipe.method];
                                    // Update instruction in method object
                                    if (typeof newMethod[index] === 'object') {
                                        newMethod[index] = { ...newMethod[index], instruction: editValue };
                                    } else {
                                        // Backwards compatibility: convert string to object
                                        newMethod[index] = {
                                            step: index + 1,
                                            instruction: editValue,
                                            duration: 0,
                                            temperature: null
                                        };
                                    }
                                    updatedRecipe = { ...recipe, method: newMethod };
                                } else if (type === 'plating') {
                                    const newPlating = [...recipe.plating];
                                    // Allow empty values
                                    newPlating[index] = editValue;
                                    updatedRecipe = { ...recipe, plating: newPlating };
                                }

                                // CRITICAL: Sync currentRecipe with the updated recipe
                                if (currentRecipe && currentRecipe.id === recipeId) {
                                    setCurrentRecipe(updatedRecipe);
                                }

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                        return updated;
                    });

                    setEditingCell(null);
                    setEditValue('');
                    setOriginalValue('');
                }
            };

            const handleDelete = (e) => {
                // Prevent blur event from triggering
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                if (micFlag) {
                    // MIC MODE: Cancel/Restore - Clear voice input and restore original value
                    if (voiceActive && recognitionRef.current) {
                        recognitionRef.current.stop();
                        setVoiceActive(false);
                    }

                    // Clear mic timer
                    if (micTimerRef.current) {
                        clearTimeout(micTimerRef.current);
                        micTimerRef.current = null;
                    }

                    // Close editing and restore original value (cancel operation)
                    setEditingCell(null);
                    setEditValue('');
                    setOriginalValue('');
                } else if (keypadFlag) {
                    // KEYPAD MODE: Clear field for fresh input
                    // Keep editing session open but clear the field
                    setEditValue('');
                    // Re-focus the input after clearing
                    setTimeout(() => {
                        if (inputRef.current) {
                            inputRef.current.focus();
                        }
                    }, 0);
                }
            };

            const scaleValue = (value, scale) => {
                if (!value) return value;
                const match = value.match(/^([\d.]+)/);
                if (match) {
                    const num = parseFloat(match[1]);
                    const scaled = (num * scale).toFixed(1);
                    return value.replace(match[1], scaled);
                }
                return value;
            };

            const startEdit = (type, recipeId, index, field, currentValue) => {
                // Silently ignore if locked
                if (!isUnlocked) return;

                // Stop search voice if active
                if (searchVoiceActive) {
                    setSearchVoiceActive(false);
                    if (searchMicTimerRef.current) {
                        clearTimeout(searchMicTimerRef.current);
                    }
                }

                // Auto-save previous field if there was one being edited
                if (editingCell) {
                    handleSend(true);
                }

                setEditingCell({ type, recipeId, index, field });
                setOriginalValue(currentValue || '');

                // In keypad mode, populate field with current value for editing
                // In mic mode, start with empty field for voice input
                if (keypadFlag) {
                    setEditValue(currentValue || '');
                } else {
                    setEditValue('');
                }

                setErrorMessage('');

                // Auto-start microphone if mic flag is ON
                if (micFlag && speechSupported) {
                    setTimeout(() => {
                        // Always try to start - don't trust stale React state
                        setVoiceActive(true);
                        setErrorMessage('');

                        try {
                            recognitionRef.current.start();
                            resetMicTimer();
                        } catch (e) {
                            if (e.message.includes('already started')) {
                                // Already running - just reset timer (this is fine!)
                                resetMicTimer();
                            } else {
                                // Real error
                                setErrorMessage('Could not start voice recognition: ' + e.message);
                            }
                        }
                    }, 50);
                }
            };

            const handleAddIngredient = () => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const updatedRecipe = {
                                    ...recipe,
                                    ingredients: [...recipe.ingredients, {
                                        measurement: { value: 0, unit: '', type: 'solid', displayValue: '' },
                                        name: '',
                                        spec: '',
                                        grouped: false
                                    }]
                                };

                                // Sync currentRecipe
                                setCurrentRecipe(updatedRecipe);

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            const handleAddMethod = () => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const newStep = recipe.method.length + 1;
                                const updatedRecipe = {
                                    ...recipe,
                                    method: [...recipe.method, {
                                        step: newStep,
                                        instruction: '',
                                        duration: 0,
                                        temperature: null
                                    }]
                                };

                                // Sync currentRecipe
                                setCurrentRecipe(updatedRecipe);

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            const handleAddPlating = () => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const updatedRecipe = {
                                    ...recipe,
                                    plating: [...recipe.plating, '']
                                };

                                // Sync currentRecipe
                                setCurrentRecipe(updatedRecipe);

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            // Delete entire recipe
            const handleDeleteRecipe = async () => {
                if (!currentRecipe) return;

                const confirmed = window.confirm(`Are you sure you want to delete "${currentRecipe.name}"? This action cannot be undone.`);

                if (confirmed) {
                    const recipeIdToDelete = currentRecipe.id;

                    // Remove from state
                    setRecipes(prev => prev.filter(recipe => recipe.id !== recipeIdToDelete));
                    setCurrentRecipe(null);
                    setPage('browser');

                    // Delete from local database
                    try {
                        await db.recipes.delete(recipeIdToDelete);
                        console.log('üóëÔ∏è Recipe deleted from database:', recipeIdToDelete);

                        // Also delete from cloud
                        if (firestoreDB) {
                            await deleteRecipeFromCloud(recipeIdToDelete);
                        }

                        setInfoMessage('‚úÖ Recipe deleted successfully');
                        setTimeout(() => setInfoMessage(''), 3000);
                    } catch (error) {
                        console.error('‚ùå Error deleting recipe from database:', error);
                        setErrorMessage('Failed to delete recipe from database');
                    }
                }
            };

            // Toggle ingredient grouping
            const handleToggleGroup = (ingredientIndex) => {
                if (!currentRecipe) return;

                // Check if recipe is currently scaled
                const isScaled = (currentRecipe.targetPortions || currentRecipe.basePortions || currentRecipe.portions) !== (currentRecipe.basePortions || currentRecipe.portions);
                if (isScaled) return;

                const updatedRecipe = {
                    ...currentRecipe,
                    ingredients: currentRecipe.ingredients.map((ing, idx) =>
                        idx === ingredientIndex
                            ? { ...ing, grouped: !ing.grouped }
                            : ing
                    )
                };

                setCurrentRecipe(updatedRecipe);
                setRecipes(prevRecipes =>
                    prevRecipes.map(recipe =>
                        recipe.id === currentRecipe.id ? updatedRecipe : recipe
                    )
                );
            };

            // Bulk dictate ingredient list
            const handleDictateList = () => {
                if (!speechSupported) {
                    setErrorMessage('Speech recognition not supported. Please use Chrome or Edge.');
                    return;
                }

                if (bulkDictating) {
                    // Stop dictation
                    stopBulkDictation();
                } else {
                    // Start dictation
                    startBulkDictation();
                }
            };

            const startBulkDictation = () => {
                setBulkDictating(true);
                setBulkTranscript('');
                setInfoMessage('üé§ Dictate your ingredient list. Will auto-stop after 5 seconds of silence...');
                setErrorMessage('');

                // Stop any existing recognition first
                try {
                    recognitionRef.current.stop();
                } catch (e) {
                    // Ignore if already stopped
                }

                // Start speech recognition
                setTimeout(() => {
                    try {
                        recognitionRef.current.start();
                        setVoiceActive(true);
                    } catch (e) {
                        console.error('Could not start recognition:', e);
                        setErrorMessage('Could not start microphone: ' + e.message);
                        setBulkDictating(false);
                        return;
                    }
                }, 100); // Small delay to ensure previous recognition is stopped

                // Initial silence timer now starts in recognition.onstart (after mic permission granted)
            };

            const stopBulkDictation = async () => {
                // Clear the parse flag since we're manually processing
                bulkShouldParse.current = false;

                setBulkDictating(false);
                setVoiceActive(false);

                // Stop recognition (won't trigger onend parsing because flag is cleared)
                if (recognitionRef.current) {
                    try {
                        recognitionRef.current.stop();
                    } catch (e) {
                        console.log('Recognition already stopped');
                    }
                }

                // Clear silence timer
                if (bulkSilenceTimerRef.current) {
                    clearTimeout(bulkSilenceTimerRef.current);
                    bulkSilenceTimerRef.current = null;
                }

                // Parse the transcript
                if (bulkTranscript.trim().length > 0) {
                    // Check if API key is set
                    if (!claudeApiKey || claudeApiKey.trim() === '') {
                        setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                        setBulkTranscript('');
                        return;
                    }

                    try {
                        setInfoMessage('ü§ñ Parsing ingredients with Claude...');
                        const ingredients = await parseIngredientListWithClaude(bulkTranscript, claudeApiKey);

                        if (ingredients.length > 0) {
                            // Add all ingredients to current recipe
                            addBulkIngredients(ingredients);
                            setInfoMessage(`‚úÖ Added ${ingredients.length} ingredient(s)!`);
                            setTimeout(() => setInfoMessage(''), 3000);
                        } else {
                            setErrorMessage('No ingredients could be parsed. Try speaking more clearly.');
                        }
                    } catch (error) {
                        setErrorMessage(`‚ùå Error parsing ingredients: ${error.message}`);
                    }
                } else {
                    setErrorMessage('No speech detected. Please try again.');
                }

                setBulkTranscript('');
            };

            const handleSaveApiKey = () => {
                if (tempApiKey.trim() === '') {
                    setErrorMessage('Please enter a valid API key');
                    return;
                }
                localStorage.setItem('claudeApiKey', tempApiKey);
                setClaudeApiKey(tempApiKey);
                setShowSettings(false);
                setInfoMessage('‚úÖ API key saved successfully!');
                setTimeout(() => setInfoMessage(''), 3000);
            };

            const handleClearApiKey = () => {
                localStorage.removeItem('claudeApiKey');
                setClaudeApiKey('');
                setTempApiKey('');
                setInfoMessage('üóëÔ∏è API key cleared');
                setTimeout(() => setInfoMessage(''), 3000);
            };

            const handleDeleteIngredient = (index) => {
                if (!confirm('Delete this ingredient?')) return;

                setRecipes(prev => {
                    return prev.map(recipe => {
                        if (recipe.id === currentRecipe.id) {
                            const updatedRecipe = {
                                ...recipe,
                                ingredients: recipe.ingredients.filter((_, i) => i !== index)
                            };
                            setCurrentRecipe(updatedRecipe);
                            return updatedRecipe;
                        }
                        return recipe;
                    });
                });
            };

            const handleDeleteMethod = (index) => {
                if (!confirm('Delete this method step?')) return;

                setRecipes(prev => {
                    return prev.map(recipe => {
                        if (recipe.id === currentRecipe.id) {
                            const updatedRecipe = {
                                ...recipe,
                                method: recipe.method.filter((_, i) => i !== index)
                            };
                            setCurrentRecipe(updatedRecipe);
                            return updatedRecipe;
                        }
                        return recipe;
                    });
                });
            };

            const handleDeletePlating = (index) => {
                if (!confirm('Delete this plating instruction?')) return;

                setRecipes(prev => {
                    return prev.map(recipe => {
                        if (recipe.id === currentRecipe.id) {
                            const updatedRecipe = {
                                ...recipe,
                                plating: recipe.plating.filter((_, i) => i !== index)
                            };
                            setCurrentRecipe(updatedRecipe);
                            return updatedRecipe;
                        }
                        return recipe;
                    });
                });
            };

            // ==================== PDF IMPORT FEATURE START ====================

            const handleImportPDF = () => {
                // Check if API key is set
                if (!claudeApiKey || claudeApiKey.trim() === '') {
                    setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                    return;
                }

                // Create file input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/pdf';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    setImportingPDF(true);
                    setInfoMessage('üìÑ Parsing PDF recipe with Claude...');
                    setErrorMessage('');

                    try {
                        const parsedRecipe = await parsePDFRecipeWithClaude(file, claudeApiKey);
                        setPreviewRecipe(parsedRecipe);
                        setInfoMessage('‚úÖ Recipe parsed! Review and confirm below.');
                    } catch (error) {
                        console.error('Error importing PDF:', error);
                        setErrorMessage('‚ùå Failed to parse PDF: ' + error.message);
                        setImportingPDF(false);
                    }
                };

                input.click();
            };

            const handleAcceptPDFRecipe = async () => {
                if (!previewRecipe) return;

                try {
                    // Add to database
                    const newRecipeId = await db.recipes.add(previewRecipe);
                    const savedRecipe = await db.recipes.get(newRecipeId);

                    // Add to state
                    setRecipes(prev => [...prev, savedRecipe]);

                    // Navigate to the new recipe view page
                    setCurrentRecipe(savedRecipe);
                    setPage('detail');

                    // Clean up
                    setImportingPDF(false);
                    setPreviewRecipe(null);
                    setInfoMessage('‚úÖ Recipe imported successfully!');
                    setTimeout(() => setInfoMessage(''), 3000);
                } catch (error) {
                    console.error('Error saving PDF recipe:', error);
                    setErrorMessage('Failed to save recipe: ' + error.message);
                }
            };

            const handleCancelPDFImport = () => {
                setImportingPDF(false);
                setPreviewRecipe(null);
                setInfoMessage('');
                setErrorMessage('');
            };

            // ==================== PDF IMPORT FEATURE END ====================

            // ==================== IMAGE IMPORT FEATURE START ====================

            const handleImportImage = () => {
                // Check if API key is set
                if (!claudeApiKey || claudeApiKey.trim() === '') {
                    setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                    return;
                }

                // Create file input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/jpeg,image/jpg,image/png,image/webp,image/heic';
                // On mobile, this will offer camera option automatically

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    setImportingPDF(true); // Reuse same state for loading indicator
                    setInfoMessage('üì∑ Parsing image recipe with Claude...');
                    setErrorMessage('');

                    try {
                        const parsedRecipe = await parseImageRecipeWithClaude(file, claudeApiKey);
                        setPreviewRecipe(parsedRecipe);
                        setInfoMessage('‚úÖ Recipe parsed! Review and confirm below.');
                    } catch (error) {
                        console.error('Error importing image:', error);
                        setErrorMessage('‚ùå Failed to parse image: ' + error.message);
                        setImportingPDF(false);
                    }
                };

                input.click();
            };

            const handleTakeImage = () => {
                // Check if API key is set
                if (!claudeApiKey || claudeApiKey.trim() === '') {
                    setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                    return;
                }

                // Create file input element with camera capture
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/jpeg,image/jpg,image/png,image/webp';
                input.capture = 'environment'; // Use rear camera on tablets/phones

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    setImportingPDF(true); // Reuse same state for loading indicator
                    setInfoMessage('üì∏ Parsing photo with Claude...');
                    setErrorMessage('');

                    try {
                        const parsedRecipe = await parseImageRecipeWithClaude(file, claudeApiKey);
                        setPreviewRecipe(parsedRecipe);
                        setInfoMessage('‚úÖ Recipe parsed! Review and confirm below.');
                    } catch (error) {
                        console.error('Error taking image:', error);
                        setErrorMessage('‚ùå Failed to parse photo: ' + error.message);
                        setImportingPDF(false);
                    }
                };

                input.click();
            };

            // ==================== IMAGE IMPORT FEATURE END ====================

            const addBulkIngredients = (ingredients) => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const updatedRecipe = {
                                    ...recipe,
                                    ingredients: [...recipe.ingredients, ...ingredients]
                                };

                                // Sync currentRecipe
                                setCurrentRecipe(updatedRecipe);

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            // Bulk dictate method steps
            const handleDictateMethodList = () => {
                if (!speechSupported) {
                    setErrorMessage('Speech recognition not supported. Please use Chrome or Edge.');
                    return;
                }

                if (bulkDictatingMethod) {
                    // Stop dictation
                    stopBulkMethodDictation();
                } else {
                    // Start dictation
                    startBulkMethodDictation();
                }
            };

            const startBulkMethodDictation = () => {
                setBulkDictatingMethod(true);
                setBulkMethodTranscript('');
                setInfoMessage('üé§ Dictate your method steps. Will auto-stop after 5 seconds of silence...');
                setErrorMessage('');

                // Stop any existing recognition first
                try {
                    recognitionRef.current.stop();
                } catch (e) {
                    // Ignore if already stopped
                }

                // Start speech recognition
                setTimeout(() => {
                    try {
                        recognitionRef.current.start();
                        setVoiceActive(true);
                    } catch (e) {
                        console.error('Could not start recognition:', e);
                        setErrorMessage('Could not start microphone: ' + e.message);
                        setBulkDictatingMethod(false);
                        return;
                    }
                }, 100); // Small delay to ensure previous recognition is stopped

                // Initial silence timer now starts in recognition.onstart (after mic permission granted)
            };

            const stopBulkMethodDictation = async () => {
                // Clear the parse flag since we're manually processing
                bulkShouldParse.current = false;

                setBulkDictatingMethod(false);
                setVoiceActive(false);

                // Stop recognition (won't trigger onend parsing because flag is cleared)
                if (recognitionRef.current) {
                    try {
                        recognitionRef.current.stop();
                    } catch (e) {
                        console.log('Recognition already stopped');
                    }
                }

                // Clear silence timer
                if (bulkSilenceTimerRef.current) {
                    clearTimeout(bulkSilenceTimerRef.current);
                    bulkSilenceTimerRef.current = null;
                }

                // Parse the transcript
                if (bulkMethodTranscript.trim().length > 0) {
                    // Check if API key is set
                    if (!claudeApiKey || claudeApiKey.trim() === '') {
                        setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                        setBulkMethodTranscript('');
                        return;
                    }

                    try {
                        setInfoMessage('ü§ñ Parsing method steps with Claude...');
                        const methodSteps = await parseMethodListWithClaude(bulkMethodTranscript, claudeApiKey);

                        if (methodSteps.length > 0) {
                            // Add all method steps to current recipe
                            addBulkMethodSteps(methodSteps);
                            setInfoMessage(`‚úÖ Added ${methodSteps.length} method step(s)!`);
                            setTimeout(() => setInfoMessage(''), 3000);
                        } else {
                            setErrorMessage('No method steps could be parsed. Try speaking more clearly.');
                        }
                    } catch (error) {
                        setErrorMessage(`‚ùå Error parsing method steps: ${error.message}`);
                    }
                } else {
                    setErrorMessage('No speech detected. Please try again.');
                }

                setBulkMethodTranscript('');
            };

            const addBulkMethodSteps = (methodSteps) => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const updatedRecipe = {
                                    ...recipe,
                                    method: [...recipe.method, ...methodSteps]
                                };

                                // Sync currentRecipe
                                setCurrentRecipe(updatedRecipe);

                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            // Bulk dictate plating steps
            const handleDictatePlatingList = () => {
                if (!speechSupported) {
                    setErrorMessage('Speech recognition not supported. Please use Chrome or Edge.');
                    return;
                }

                if (bulkDictatingPlating) {
                    stopBulkPlatingDictation();
                } else {
                    startBulkPlatingDictation();
                }
            };

            const startBulkPlatingDictation = () => {
                setBulkDictatingPlating(true);
                setBulkPlatingTranscript('');
                setInfoMessage('üé§ Dictate your plating steps. Will auto-stop after 5 seconds of silence...');
                setErrorMessage('');

                // Stop any existing recognition first
                try {
                    recognitionRef.current.stop();
                } catch (e) {
                    // Ignore if already stopped
                }

                // Start speech recognition
                setTimeout(() => {
                    try {
                        recognitionRef.current.start();
                        setVoiceActive(true);
                    } catch (e) {
                        console.error('Could not start recognition:', e);
                        setErrorMessage('Could not start microphone: ' + e.message);
                        setBulkDictatingPlating(false);
                        return;
                    }
                }, 100); // Small delay to ensure previous recognition is stopped

                // Initial silence timer now starts in recognition.onstart (after mic permission granted)
            };

            const stopBulkPlatingDictation = async () => {
                bulkShouldParse.current = false;
                setBulkDictatingPlating(false);
                setVoiceActive(false);

                if (recognitionRef.current) {
                    try {
                        recognitionRef.current.stop();
                    } catch (e) {
                        console.log('Recognition already stopped');
                    }
                }

                if (bulkSilenceTimerRef.current) {
                    clearTimeout(bulkSilenceTimerRef.current);
                    bulkSilenceTimerRef.current = null;
                }

                if (bulkPlatingTranscript.trim().length > 0) {
                    if (!claudeApiKey || claudeApiKey.trim() === '') {
                        setErrorMessage('‚ö†Ô∏è Claude API key not set. Please click Settings (‚öôÔ∏è) to add your API key.');
                        setBulkPlatingTranscript('');
                        return;
                    }

                    try {
                        setInfoMessage('ü§ñ Parsing plating steps with Claude...');
                        const platingSteps = await parsePlatingListWithClaude(bulkPlatingTranscript, claudeApiKey);

                        if (platingSteps.length > 0) {
                            addBulkPlatingSteps(platingSteps);
                            setInfoMessage(`‚úÖ Added ${platingSteps.length} plating step(s)!`);
                            setTimeout(() => setInfoMessage(''), 3000);
                        } else {
                            setErrorMessage('No plating steps could be parsed. Try speaking more clearly.');
                        }
                    } catch (error) {
                        setErrorMessage(`‚ùå Error parsing plating steps: ${error.message}`);
                    }
                } else {
                    setErrorMessage('No speech detected. Please try again.');
                }

                setBulkPlatingTranscript('');
            };

            const addBulkPlatingSteps = (platingSteps) => {
                if (currentRecipe) {
                    setRecipes(prev => {
                        return prev.map(recipe => {
                            if (recipe.id === currentRecipe.id) {
                                const updatedRecipe = {
                                    ...recipe,
                                    plating: [...recipe.plating, ...platingSteps]
                                };
                                setCurrentRecipe(updatedRecipe);
                                return updatedRecipe;
                            }
                            return recipe;
                        });
                    });
                }
            };

            const handleNewRecipe = () => {
                setPage('category');
                setIsNewRecipe(true);
            };

            const handleCategorySelect = (category) => {
                const newRecipe = {
                    id: Date.now(),
                    name: 'New Recipe',
                    category: category,
                    portions: 4,
                    basePortions: 4,
                    // targetPortions intentionally not set - will default to basePortions
                    ingredients: [],
                    method: [],
                    plating: [],
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    version: 1,
                    syncStatus: 'local'
                };
                setCurrentRecipe(newRecipe);
                setRecipes(prev => [...prev, newRecipe]);
                setPage('detail');
            };

            const handleSaveNewRecipe = () => {
                setIsNewRecipe(false);
                setPage('browser');
            };

            const startTimer = () => {
                const seconds = parseInt(timerValue) || 60;
                const newTimer = {
                    id: Date.now(),
                    remaining: seconds,
                    total: seconds,
                    alert: false
                };
                setActiveTimers(prev => [...prev, newTimer]);
                setTimerValue('');
            };

            useEffect(() => {
                const interval = setInterval(() => {
                    setActiveTimers(prev => prev.map(timer => {
                        if (timer.remaining > 0) {
                            return { ...timer, remaining: timer.remaining - 1 };
                        } else {
                            return { ...timer, alert: true };
                        }
                    }));
                }, 1000);
                return () => clearInterval(interval);
            }, []);

            const dismissTimer = (id) => {
                setActiveTimers(prev => prev.filter(t => t.id !== id));
            };

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const filteredRecipes = recipes.filter(r => {
                const matchesSearch = r.name.toLowerCase().includes(searchQuery.toLowerCase());
                const matchesCategory = categoryFilter === 'All' || r.category === categoryFilter;
                const firstLetter = r.name.toUpperCase().charAt(0);
                const matchesLetter = firstLetter >= letterFilter;
                return matchesSearch && matchesCategory && matchesLetter;
            }).sort((a, b) => a.name.localeCompare(b.name));

            return (
                <div className="app">
                    {/* Global Menu Bar */}
                    <div className="menu-bar">
                        <div className="app-name">
                            Kitchen Recipe Manager üé§
                            <span
                                onClick={() => setShowDepartmentModal(true)}
                                style={{
                                    fontSize: '14px',
                                    marginLeft: '15px',
                                    padding: '5px 12px',
                                    background: '#3498db',
                                    color: 'white',
                                    borderRadius: '15px',
                                    fontWeight: 'normal',
                                    cursor: 'pointer',
                                    display: 'inline-block',
                                    transition: 'all 0.2s'
                                }}
                                onMouseEnter={(e) => e.target.style.background = '#2980b9'}
                                onMouseLeave={(e) => e.target.style.background = '#3498db'}
                                title="Click to switch department"
                            >
                                üè¢ {currentDepartment}
                            </span>
                        </div>
                        {page === 'detail' && (
                            <button
                                className="menu-button"
                                onClick={() => setPage('browser')}
                                title="Back to recipe list"
                            >
                                ‚Üê Back
                            </button>
                        )}
                        <button
                            className={`menu-button flag ${micFlag ? 'active' : ''}`}
                            onClick={() => {
                                setMicFlag(!micFlag);
                                if (!micFlag) setKeypadFlag(false); // Turn off keypad when turning on mic
                            }}
                            title="Toggle voice input"
                        >
                            üé§
                        </button>
                        <button
                            className={`menu-button flag ${keypadFlag ? 'active' : ''}`}
                            onClick={() => {
                                setKeypadFlag(!keypadFlag);
                                if (!keypadFlag) setMicFlag(false); // Turn off mic when turning on keypad
                            }}
                            title="Toggle keyboard input"
                        >
                            ‚å®Ô∏è
                        </button>
                        <button
                            className="menu-button"
                            onClick={() => { if (isUnlocked) handleNewRecipe(); }}
                        >
                            + New
                        </button>
                        <button className="menu-button" onClick={() => setShowTimer(!showTimer)}>
                            ‚è±Ô∏è
                        </button>

                        {/* Dropdown Menu */}
                        <div className="dropdown">
                            <button
                                className="menu-button"
                                onClick={() => setShowDropdown(!showDropdown)}
                                title="More options"
                            >
                                ‚ãÆ
                            </button>
                            <div className={`dropdown-content ${showDropdown ? 'show' : ''}`}>
                                {isUnlocked && (
                                    <>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => { handleImportPDF(); setShowDropdown(false); }}
                                        >
                                            <span>üìÑ</span> Import PDF
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => { handleImportImage(); setShowDropdown(false); }}
                                        >
                                            <span>üì∑</span> Import Image
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => { handleTakeImage(); setShowDropdown(false); }}
                                        >
                                            <span>üì∏</span> Take Image
                                        </button>
                                        <div className="dropdown-divider"></div>
                                    </>
                                )}
                                {page === 'detail' && currentRecipe && isUnlocked && (
                                    <>
                                        <button
                                            className="dropdown-item danger"
                                            onClick={() => { handleDeleteRecipe(); setShowDropdown(false); }}
                                        >
                                            <span>üóëÔ∏è</span> Delete Recipe
                                        </button>
                                        <div className="dropdown-divider"></div>
                                    </>
                                )}
                                <button className="dropdown-item" onClick={() => { setTempApiKey(claudeApiKey); setShowSettings(true); setShowDropdown(false); }}>
                                    <span>‚öôÔ∏è</span> Settings
                                </button>
                                <div className="dropdown-divider"></div>
                                {isUnlocked ? (
                                    <button className="dropdown-item" onClick={() => { handleLock(); setShowDropdown(false); }}>
                                        <span>üîí</span> Lock (View Only)
                                    </button>
                                ) : (
                                    <button className="dropdown-item" onClick={() => { setShowPasswordModal(true); setShowDropdown(false); }}>
                                        <span>üîì</span> Unlock (Edit Mode)
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Settings Modal */}
                    {showSettings && (
                        <div className="settings-overlay">
                            <div className="settings-modal">
                                <div className="settings-header">
                                    <span>‚öôÔ∏è Settings</span>
                                    <button className="settings-close" onClick={() => setShowSettings(false)}>‚úï</button>
                                </div>

                                <div className="settings-info">
                                    <strong>ü§ñ Claude API Key</strong><br/>
                                    Required for the "Dictate List" feature to parse ingredients using AI.<br/><br/>
                                    Get your API key from: <strong>console.anthropic.com</strong><br/>
                                    Cost: ~$0.0001 per recipe (pennies!)
                                </div>

                                <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>
                                    API Key:
                                </label>
                                <input
                                    type="password"
                                    className="settings-input"
                                    placeholder="sk-ant-api03-..."
                                    value={tempApiKey}
                                    onChange={(e) => setTempApiKey(e.target.value)}
                                />

                                <div style={{fontSize: '12px', color: '#7f8c8d', marginBottom: '10px'}}>
                                    {claudeApiKey ? '‚úÖ API key is currently set' : '‚ö†Ô∏è No API key set'}
                                </div>

                                <div className="settings-buttons">
                                    <button className="settings-button save" onClick={handleSaveApiKey}>
                                        Save Key
                                    </button>
                                    <button className="settings-button clear" onClick={handleClearApiKey}>
                                        Clear Key
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Password Modal for Lock/Unlock */}
                    {showPasswordModal && (
                        <div className="settings-overlay">
                            <div className="settings-modal">
                                <div className="settings-header">
                                    <span>üîì Unlock Edit Mode</span>
                                    <button className="settings-close" onClick={() => {
                                        setShowPasswordModal(false);
                                        setPasswordInput('');
                                    }}>‚úï</button>
                                </div>

                                <div className="settings-info">
                                    <strong>üîí Edit Protection</strong><br/>
                                    Enter the master password to unlock editing, creating, and deleting recipes.<br/><br/>
                                    The app will auto-lock after 30 minutes of inactivity.
                                </div>

                                <form onSubmit={(e) => {
                                    e.preventDefault();
                                    handleUnlock();
                                }}>
                                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>
                                        Password:
                                    </label>
                                    <input
                                        type="password"
                                        className="settings-input"
                                        placeholder="Enter master password"
                                        value={passwordInput}
                                        onChange={(e) => setPasswordInput(e.target.value)}
                                        required
                                        autoFocus
                                        style={{marginBottom: '15px'}}
                                    />

                                    <div className="settings-buttons">
                                        <button type="submit" className="settings-button save">
                                            üîì Unlock
                                        </button>
                                        <button
                                            type="button"
                                            className="settings-button cancel"
                                            onClick={() => {
                                                setShowPasswordModal(false);
                                                setPasswordInput('');
                                            }}
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}

                    {/* Department Switch Modal */}
                    {showDepartmentModal && (
                        <div className="settings-overlay">
                            <div className="settings-modal">
                                <div className="settings-header">
                                    <span>üè¢ Switch Department</span>
                                    <button className="settings-close" onClick={() => setShowDepartmentModal(false)}>‚úï</button>
                                </div>

                                <div className="settings-info">
                                    <strong>üìÇ Department Filter</strong><br/>
                                    Select a department to view and manage recipes for that area.<br/><br/>
                                    Each department has its own recipe collection.
                                </div>

                                <div style={{display: 'flex', flexDirection: 'column', gap: '10px', marginTop: '20px'}}>
                                    {DEPARTMENTS.map(dept => (
                                        <button
                                            key={dept}
                                            className={dept === currentDepartment ? 'settings-button save' : 'settings-button'}
                                            onClick={() => handleSwitchDepartment(dept)}
                                            style={{
                                                width: '100%',
                                                fontSize: '16px',
                                                padding: '12px',
                                                background: dept === currentDepartment ? '#27ae60' : '#3498db',
                                                color: 'white',
                                                border: 'none',
                                                cursor: 'pointer'
                                            }}
                                        >
                                            {dept === currentDepartment ? '‚úì ' : ''}üè¢ {dept}
                                        </button>
                                    ))}
                                </div>

                                <div className="settings-buttons" style={{marginTop: '20px'}}>
                                    <button
                                        className="settings-button cancel"
                                        onClick={() => setShowDepartmentModal(false)}
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Marketing Generator Modal */}
                    {showMarketingModal && currentRecipe && (
                        <div className="settings-overlay">
                            <div className="settings-modal" style={{maxWidth: '800px', maxHeight: '90vh', overflowY: 'auto'}}>
                                <div className="settings-header">
                                    <span>üì¢ Marketing Generator</span>
                                    <button className="settings-close" onClick={() => {
                                        setShowMarketingModal(false);
                                        setMarketingResults([]);
                                        setMarketingImage(null);
                                        setMarketingImageUrl('');
                                    }}>‚úï</button>
                                </div>

                                <div className="settings-info">
                                    <strong>üéØ Generate Social Media Content</strong><br/>
                                    Create professional marketing copy for: <strong>{currentRecipe.name}</strong><br/><br/>
                                    Select your promotion style below and let AI create engaging social media posts!
                                </div>

                                <div style={{display: 'flex', flexDirection: 'column', gap: '15px', marginTop: '20px'}}>
                                    {/* Context Selection */}
                                    <div>
                                        <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px'}}>
                                            üìÖ Context / Occasion:
                                        </label>
                                        <select
                                            className="settings-input"
                                            value={marketingContext}
                                            onChange={(e) => setMarketingContext(e.target.value)}
                                        >
                                            <option value="Daily Special">Daily Special</option>
                                            <option value="Weekend Feature">Weekend Feature</option>
                                            <option value="New Menu Item">New Menu Item</option>
                                            <option value="Chef's Special">Chef's Special</option>
                                            <option value="Customer Favorite">Customer Favorite</option>
                                            <option value="Limited Time Offer">Limited Time Offer</option>
                                            <option value="Summer BBQ Season">Summer BBQ Season</option>
                                            <option value="Fall Comfort Food">Fall Comfort Food</option>
                                            <option value="Winter Warmer">Winter Warmer</option>
                                            <option value="Spring Fresh">Spring Fresh</option>
                                            <option value="Holiday Special">Holiday Special</option>
                                            <option value="Valentine's Day">Valentine's Day</option>
                                            <option value="Mother's Day">Mother's Day</option>
                                            <option value="Game Day">Game Day</option>
                                        </select>
                                    </div>

                                    {/* Tone Selection */}
                                    <div>
                                        <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px'}}>
                                            üé≠ Tone & Style:
                                        </label>
                                        <select
                                            className="settings-input"
                                            value={marketingTone}
                                            onChange={(e) => setMarketingTone(e.target.value)}
                                        >
                                            <option value="Casual & Friendly">Casual & Friendly</option>
                                            <option value="Elegant & Gourmet">Elegant & Gourmet</option>
                                            <option value="Playful & Fun">Playful & Fun</option>
                                            <option value="Healthy & Fresh">Healthy & Fresh</option>
                                            <option value="Traditional & Authentic">Traditional & Authentic</option>
                                            <option value="Modern & Trendy">Modern & Trendy</option>
                                            <option value="Romantic & Intimate">Romantic & Intimate</option>
                                            <option value="Family-Friendly">Family-Friendly</option>
                                        </select>
                                    </div>

                                    {/* Platform Selection */}
                                    <div>
                                        <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px'}}>
                                            üì± Platform:
                                        </label>
                                        <select
                                            className="settings-input"
                                            value={marketingPlatform}
                                            onChange={(e) => setMarketingPlatform(e.target.value)}
                                        >
                                            <option value="Instagram">Instagram</option>
                                            <option value="Facebook">Facebook</option>
                                            <option value="Twitter">Twitter</option>
                                            <option value="Restaurant Website">Restaurant Website</option>
                                        </select>
                                    </div>

                                    {/* Image Upload */}
                                    <div>
                                        <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '14px'}}>
                                            üì∏ Dish Photo:
                                        </label>
                                        <div style={{display: 'flex', gap: '10px', alignItems: 'center'}}>
                                            <input
                                                type="file"
                                                accept="image/*"
                                                onChange={(e) => {
                                                    const file = e.target.files[0];
                                                    if (file) {
                                                        const reader = new FileReader();
                                                        reader.onload = (event) => {
                                                            setMarketingImage(event.target.result);
                                                            setMarketingImageUrl('');
                                                        };
                                                        reader.readAsDataURL(file);
                                                    }
                                                }}
                                                style={{flex: 1}}
                                            />
                                            {marketingImage && (
                                                <button
                                                    onClick={() => {
                                                        setMarketingImage(null);
                                                        setMarketingImageUrl('');
                                                    }}
                                                    style={{
                                                        padding: '6px 12px',
                                                        background: '#e74c3c',
                                                        color: 'white',
                                                        border: 'none',
                                                        borderRadius: '4px',
                                                        cursor: 'pointer',
                                                        fontSize: '12px'
                                                    }}
                                                >
                                                    ‚úï Remove
                                                </button>
                                            )}
                                        </div>
                                        {marketingImage && (
                                            <img
                                                src={marketingImage}
                                                alt="Preview"
                                                style={{
                                                    width: '100%',
                                                    maxHeight: '200px',
                                                    objectFit: 'cover',
                                                    borderRadius: '8px',
                                                    marginTop: '10px'
                                                }}
                                            />
                                        )}
                                        <div style={{fontSize: '12px', color: '#7f8c8d', marginTop: '5px'}}>
                                            üí° If no photo is uploaded, AI will suggest a free stock image based on your dish
                                        </div>
                                    </div>

                                    {/* Generate Button */}
                                    <button
                                        className="settings-button save"
                                        onClick={generateMarketingCopy}
                                        disabled={generatingMarketing}
                                        style={{
                                            fontSize: '16px',
                                            padding: '12px',
                                            marginTop: '10px',
                                            opacity: generatingMarketing ? 0.6 : 1
                                        }}
                                    >
                                        {generatingMarketing ? '‚ú® Generating...' : '‚ú® Generate Marketing Copy'}
                                    </button>

                                    {/* Results Section */}
                                    {marketingResults.length > 0 && (
                                        <div style={{marginTop: '20px', borderTop: '2px solid #ecf0f1', paddingTop: '20px'}}>
                                            <h3 style={{marginBottom: '15px', color: '#2c3e50'}}>üìù Generated Promotions:</h3>
                                            {marketingResults.map((result, idx) => (
                                                <div
                                                    key={idx}
                                                    style={{
                                                        background: '#f8f9fa',
                                                        padding: '15px',
                                                        borderRadius: '8px',
                                                        marginBottom: '15px',
                                                        border: '2px solid #e9ecef'
                                                    }}
                                                >
                                                    <h4 style={{color: '#e67e22', marginBottom: '10px'}}>{result.title}</h4>
                                                    <div style={{
                                                        background: 'white',
                                                        padding: '15px',
                                                        borderRadius: '5px',
                                                        marginBottom: '10px',
                                                        whiteSpace: 'pre-wrap',
                                                        fontFamily: 'inherit',
                                                        fontSize: '14px',
                                                        lineHeight: '1.6'
                                                    }}>
                                                        {result.copy}
                                                    </div>
                                                    <div style={{
                                                        fontSize: '13px',
                                                        color: '#3498db',
                                                        marginBottom: '10px'
                                                    }}>
                                                        {result.hashtags}
                                                    </div>
                                                    <div style={{display: 'flex', gap: '10px'}}>
                                                        <button
                                                            className="settings-button"
                                                            onClick={() => {
                                                                const fullText = `${result.copy}\n\n${result.hashtags}`;
                                                                navigator.clipboard.writeText(fullText);
                                                                setInfoMessage('üìã Copied to clipboard!');
                                                                setTimeout(() => setInfoMessage(''), 3000);
                                                            }}
                                                            style={{
                                                                background: '#27ae60',
                                                                color: 'white',
                                                                fontSize: '14px',
                                                                padding: '8px 16px',
                                                                flex: 1
                                                            }}
                                                        >
                                                            üìã Copy to Clipboard
                                                        </button>
                                                        <button
                                                            className="settings-button"
                                                            onClick={() => {
                                                                console.log('üñºÔ∏è Preview Debug:');
                                                                console.log('  - marketingImage:', marketingImage ? 'YES (uploaded)' : 'NO');
                                                                console.log('  - marketingImageUrl:', marketingImageUrl);
                                                                const imageToShow = marketingImage || marketingImageUrl;
                                                                console.log('  - imageToShow (final):', imageToShow ? imageToShow.substring(0, 60) + '...' : 'NONE');

                                                                const previewWindow = window.open('', '_blank', 'width=500,height=800');
                                                                const fullPost = result.copy + '\n\n' + result.hashtags;

                                                                // Build HTML with proper string escaping
                                                                const previewHTML = `
                                                                    <!DOCTYPE html>
                                                                    <html>
                                                                    <head>
                                                                        <title>Social Media Preview - ${currentRecipe.name}</title>
                                                                        <meta charset="UTF-8">
                                                                        <script>
                                                                            console.log('üñºÔ∏è Preview Window - Image URL:', '${imageToShow}');
                                                                        <\/script>
                                                                        <style>
                                                                            body {
                                                                                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                                                                                background: #f0f2f5;
                                                                                margin: 0;
                                                                                padding: 20px;
                                                                            }
                                                                            .preview-container {
                                                                                max-width: 500px;
                                                                                margin: 0 auto;
                                                                                background: white;
                                                                                border-radius: 8px;
                                                                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                                                                overflow: hidden;
                                                                            }
                                                                            .post-header {
                                                                                display: flex;
                                                                                align-items: center;
                                                                                padding: 12px 16px;
                                                                                border-bottom: 1px solid #e4e6eb;
                                                                            }
                                                                            .profile-pic {
                                                                                width: 40px;
                                                                                height: 40px;
                                                                                border-radius: 50%;
                                                                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                                                                display: flex;
                                                                                align-items: center;
                                                                                justify-content: center;
                                                                                font-size: 20px;
                                                                                margin-right: 12px;
                                                                            }
                                                                            .post-info {
                                                                                flex: 1;
                                                                            }
                                                                            .restaurant-name {
                                                                                font-weight: 600;
                                                                                font-size: 15px;
                                                                                color: #050505;
                                                                            }
                                                                            .post-time {
                                                                                font-size: 13px;
                                                                                color: #65676b;
                                                                            }
                                                                            .post-content {
                                                                                padding: 16px;
                                                                                font-size: 15px;
                                                                                line-height: 1.6;
                                                                                color: #050505;
                                                                                white-space: pre-wrap;
                                                                            }
                                                                            .hashtags {
                                                                                color: #1877f2;
                                                                                font-weight: 500;
                                                                            }
                                                                            .post-image {
                                                                                width: 100%;
                                                                                height: 300px;
                                                                                background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
                                                                                display: flex;
                                                                                align-items: center;
                                                                                justify-content: center;
                                                                                color: white;
                                                                                font-size: 48px;
                                                                            }
                                                                            .post-actions {
                                                                                padding: 8px 16px;
                                                                                border-top: 1px solid #e4e6eb;
                                                                                display: flex;
                                                                                gap: 12px;
                                                                            }
                                                                            .action-button {
                                                                                flex: 1;
                                                                                padding: 8px;
                                                                                background: none;
                                                                                border: none;
                                                                                border-radius: 4px;
                                                                                cursor: pointer;
                                                                                font-size: 15px;
                                                                                color: #65676b;
                                                                                font-weight: 600;
                                                                                transition: background 0.2s;
                                                                            }
                                                                            .action-button:hover {
                                                                                background: #f2f3f5;
                                                                            }
                                                                            .platform-badge {
                                                                                position: fixed;
                                                                                top: 20px;
                                                                                right: 20px;
                                                                                background: #1877f2;
                                                                                color: white;
                                                                                padding: 8px 16px;
                                                                                border-radius: 20px;
                                                                                font-weight: 600;
                                                                                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                                                                            }
                                                                        </style>
                                                                    </head>
                                                                    <body>
                                                                        <div class="platform-badge">üì± ${marketingPlatform} Preview</div>

                                                                        <div class="preview-container">
                                                                            <div class="post-header">
                                                                                <div class="profile-pic">üçΩÔ∏è</div>
                                                                                <div class="post-info">
                                                                                    <div class="restaurant-name">Your Restaurant Name</div>
                                                                                    <div class="post-time">Just now ¬∑ üåê</div>
                                                                                </div>
                                                                            </div>

                                                                            ${imageToShow ? `
                                                                                <img
                                                                                    src="${imageToShow}"
                                                                                    alt="${currentRecipe.name}"
                                                                                    style="width: 100%; height: auto; display: block;"
                                                                                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                                                />
                                                                                <div class="post-image" style="display: none;">
                                                                                    üçΩÔ∏è
                                                                                </div>
                                                                            ` : `
                                                                                <div class="post-image">
                                                                                    üçΩÔ∏è
                                                                                </div>
                                                                            `}

                                                                            <div class="post-content">${result.copy.replace(/\n/g, '<br>')}</div>

                                                                            <div class="post-content hashtags">${result.hashtags}</div>

                                                                            <div class="post-actions">
                                                                                <button class="action-button">üëç Like</button>
                                                                                <button class="action-button">üí¨ Comment</button>
                                                                                <button class="action-button">‚ÜóÔ∏è Share</button>
                                                                            </div>
                                                                        </div>
                                                                    </body>
                                                                    </html>
                                                                `;

                                                                previewWindow.document.write(previewHTML);
                                                                previewWindow.document.close();
                                                            }}
                                                            style={{
                                                                background: '#1877f2',
                                                                color: 'white',
                                                                fontSize: '14px',
                                                                padding: '8px 16px',
                                                                flex: 1
                                                            }}
                                                        >
                                                            üëÅÔ∏è Preview Post
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                <div className="settings-buttons" style={{marginTop: '20px'}}>
                                    <button
                                        className="settings-button cancel"
                                        onClick={() => {
                                            setShowMarketingModal(false);
                                            setMarketingResults([]);
                                            setMarketingImage(null);
                                            setMarketingImageUrl('');
                                        }}
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Timer Overlay */}
                    {showTimer && (
                        <div className="timer-overlay">
                            <div className="timer-header">
                                <strong>Timers</strong>
                                <button className="timer-close" onClick={() => setShowTimer(false)}>‚úï</button>
                            </div>
                            
                            <input
                                type="number"
                                className="timer-input"
                                placeholder="Seconds"
                                value={timerValue}
                                onChange={(e) => setTimerValue(e.target.value)}
                            />
                            <button className="timer-start" onClick={startTimer}>Start Timer</button>
                            
                            {activeTimers.map(timer => (
                                <div key={timer.id}>
                                    {timer.alert && (
                                        <div className="timer-alert">
                                            TIME'S UP!
                                            <button 
                                                className="timer-close" 
                                                style={{marginLeft: '10px'}}
                                                onClick={() => dismissTimer(timer.id)}
                                            >
                                                Dismiss
                                            </button>
                                        </div>
                                    )}
                                    {!timer.alert && (
                                        <div className="timer-display">
                                            {formatTime(timer.remaining)}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}

                    {/* Messages */}
                    {errorMessage && (
                        <div className="error-message">
                            {errorMessage}
                            <button 
                                style={{marginLeft: '10px', background: 'white', color: '#e74c3c', border: 'none', padding: '5px 10px', borderRadius: '3px', cursor: 'pointer'}}
                                onClick={() => setErrorMessage('')}
                            >
                                ‚úï
                            </button>
                        </div>
                    )}
                    
                    {infoMessage && (
                        <div className="info-message">
                            {infoMessage}
                        </div>
                    )}

                    {/* Dictation Display Box - Ingredients */}
                    {bulkDictating && (
                        <div className="dictation-box">
                            <div className="dictation-header">
                                <div className="dictation-pulse"></div>
                                <span>üé§ Listening... (Auto-stop after 5 seconds of silence)</span>
                            </div>
                            <div className="dictation-text">
                                {bulkTranscript || <span className="dictation-empty">Start speaking your ingredients...</span>}
                            </div>
                        </div>
                    )}

                    {/* Dictation Display Box - Method */}
                    {bulkDictatingMethod && (
                        <div className="dictation-box">
                            <div className="dictation-header">
                                <div className="dictation-pulse"></div>
                                <span>üé§ Listening... (Auto-stop after 5 seconds of silence)</span>
                            </div>
                            <div className="dictation-text">
                                {bulkMethodTranscript || <span className="dictation-empty">Start speaking your method steps...</span>}
                            </div>
                        </div>
                    )}

                    {/* Dictation Display Box - Plating */}
                    {bulkDictatingPlating && (
                        <div className="dictation-box">
                            <div className="dictation-header">
                                <div className="dictation-pulse"></div>
                                <span>üé§ Listening... (Auto-stop after 5 seconds of silence)</span>
                            </div>
                            <div className="dictation-text">
                                {bulkPlatingTranscript || <span className="dictation-empty">Start speaking your plating steps...</span>}
                            </div>
                        </div>
                    )}

                    {/* Page: Recipe Browser */}
                    {page === 'browser' && (
                        <>
                            <div className="search-section">
                                <div style={{display: 'flex', gap: '10px', alignItems: 'center', marginBottom: '20px'}}>
                                    <div className="search-bar" style={{flex: 1}}>
                                        <input
                                            className={`search-input ${searchVoiceActive ? 'pulsing' : ''}`}
                                            type="text"
                                            placeholder="Search recipes..."
                                            value={searchQuery}
                                            onChange={(e) => setSearchQuery(e.target.value)}
                                            onClick={handleSearchClick}
                                        />
                                        <button
                                            className="search-button"
                                            onClick={handleSearchSend}
                                        >
                                            Send
                                        </button>
                                    </div>
                                    <select
                                        value={categoryFilter}
                                        onChange={(e) => setCategoryFilter(e.target.value)}
                                        style={{
                                            padding: '10px 15px',
                                            fontSize: '16px',
                                            border: '2px solid #bdc3c7',
                                            borderRadius: '8px',
                                            background: 'white',
                                            cursor: 'pointer',
                                            minWidth: '180px'
                                        }}
                                    >
                                        <option value="All">All Categories</option>
                                        {CATEGORIES.map(cat => (
                                            <option key={cat} value={cat}>{cat}</option>
                                        ))}
                                    </select>
                                </div>
                            </div>

                            <div style={{display: 'flex', gap: '10px', position: 'relative'}}>
                                <div className="recipe-list" style={{flex: 1}}>
                                    {filteredRecipes.length === 0 ? (
                                        <div className="empty-state">
                                            No recipes yet. Create your first recipe!
                                        </div>
                                    ) : (
                                        filteredRecipes.map(recipe => (
                                            <button
                                                key={recipe.id}
                                                data-recipe-id={recipe.id}
                                                className="recipe-button"
                                                onClick={() => {
                                                    setCurrentRecipe(recipe);
                                                    setPage('detail');
                                                }}
                                            >
                                                {recipe.name}
                                            </button>
                                        ))
                                    )}
                                </div>

                                {/* A-Z Navigation Menu */}
                                <div style={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    gap: '2px',
                                    padding: '10px 5px',
                                    background: '#ecf0f1',
                                    borderRadius: '8px',
                                    height: 'fit-content',
                                    maxHeight: '600px',
                                    overflowY: 'auto',
                                    position: 'sticky',
                                    top: '10px'
                                }}>
                                    {Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ').map(letter => {
                                        // Check if any recipe exists from this letter onwards
                                        const hasRecipes = recipes.some(r => {
                                            const matchesCategory = categoryFilter === 'All' || r.category === categoryFilter;
                                            const matchesSearch = r.name.toLowerCase().includes(searchQuery.toLowerCase());
                                            const firstLetter = r.name.toUpperCase().charAt(0);
                                            return matchesCategory && matchesSearch && firstLetter >= letter;
                                        });
                                        const isActive = letterFilter === letter;
                                        return (
                                            <button
                                                key={letter}
                                                onClick={() => setLetterFilter(letter)}
                                                style={{
                                                    padding: '4px 10px',
                                                    fontSize: '14px',
                                                    fontWeight: hasRecipes ? 'bold' : 'normal',
                                                    color: hasRecipes ? (isActive ? 'white' : '#2c3e50') : '#95a5a6',
                                                    background: isActive ? '#3498db' : 'transparent',
                                                    border: 'none',
                                                    cursor: hasRecipes ? 'pointer' : 'default',
                                                    borderRadius: '4px',
                                                    transition: 'background 0.2s'
                                                }}
                                                onMouseEnter={(e) => {
                                                    if (hasRecipes && !isActive) e.target.style.background = '#3498db';
                                                    if (hasRecipes && !isActive) e.target.style.color = 'white';
                                                }}
                                                onMouseLeave={(e) => {
                                                    if (!isActive) e.target.style.background = 'transparent';
                                                    if (!isActive) e.target.style.color = hasRecipes ? '#2c3e50' : '#95a5a6';
                                                }}
                                                disabled={!hasRecipes}
                                            >
                                                {letter}
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        </>
                    )}

                    {/* Page: Category Selection */}
                    {page === 'category' && (
                        <div className="category-grid">
                            {CATEGORIES.map(cat => (
                                <button
                                    key={cat}
                                    className="category-button"
                                    onClick={() => handleCategorySelect(cat)}
                                >
                                    {cat}
                                </button>
                            ))}
                        </div>
                    )}

                    {/* Page: Recipe Detail */}
                    {page === 'detail' && currentRecipe && (
                        <div className="recipe-detail" style={{paddingTop: '5px'}}>
                            <div className="recipe-header" style={{display: 'flex', alignItems: 'center', gap: '15px', marginBottom: '10px', flexWrap: 'wrap'}}>
                                <div
                                    className="recipe-name"
                                    onClick={() => startEdit('name', currentRecipe.id, null, null, currentRecipe.name)}
                                    style={{flex: '1 1 auto', minWidth: '200px'}}
                                >
                                    {editingCell?.type === 'name' ? (
                                        <div style={{display: 'flex', gap: '10px', alignItems: 'center'}}>
                                            <input
                                                ref={inputRef}
                                                className="edit-input"
                                                value={editValue}
                                                onChange={(e) => setEditValue(e.target.value)}
                                                onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                onBlur={handleSend}
                                            />
                                            <div className="edit-buttons">
                                                <button className="edit-btn delete" onMouseDown={handleDelete}>‚úï</button>
                                            </div>
                                        </div>
                                    ) : currentRecipe.name}
                                </div>

                                {/* Category Dropdown */}
                                <div style={{display: 'flex', alignItems: 'center', gap: '5px'}}>
                                    <span style={{fontSize: '14px', color: '#7f8c8d'}}>Category:</span>
                                    <select
                                        value={currentRecipe.category || 'Main Courses'}
                                        onChange={(e) => {
                                            if (!isUnlocked) return;
                                            const newCategory = e.target.value;
                                            setRecipes(prev => prev.map(r =>
                                                r.id === currentRecipe.id
                                                    ? {...r, category: newCategory}
                                                    : r
                                            ));
                                            setCurrentRecipe(prev => ({...prev, category: newCategory}));
                                        }}
                                        style={{
                                            padding: '6px 10px',
                                            fontSize: '14px',
                                            border: '2px solid #bdc3c7',
                                            borderRadius: '5px',
                                            background: 'white',
                                            minWidth: '150px',
                                            pointerEvents: !isUnlocked ? 'none' : 'auto'
                                        }}
                                    >
                                        {CATEGORIES.map(cat => (
                                            <option key={cat} value={cat}>{cat}</option>
                                        ))}
                                    </select>
                                </div>

                                {/* Department Tag */}
                                <div style={{display: 'flex', alignItems: 'center', gap: '5px'}}>
                                    <span
                                        style={{
                                            fontSize: '12px',
                                            padding: '4px 10px',
                                            background: '#3498db',
                                            color: 'white',
                                            borderRadius: '12px',
                                            fontWeight: 'normal'
                                        }}
                                        title="Recipe department"
                                    >
                                        üè¢ {currentRecipe.department || currentDepartment}
                                    </span>
                                </div>

                                {/* Promote Button (Owner Only) */}
                                {isUnlocked && (
                                    <button
                                        onClick={() => setShowMarketingModal(true)}
                                        style={{
                                            padding: '8px 16px',
                                            fontSize: '14px',
                                            background: '#e67e22',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: 'bold',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px',
                                            transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={(e) => e.target.style.background = '#d35400'}
                                        onMouseLeave={(e) => e.target.style.background = '#e67e22'}
                                        title="Generate marketing content for social media"
                                    >
                                        üì¢ Promote This Dish
                                    </button>
                                )}

                                <div style={{display: 'flex', gap: '10px', alignItems: 'center'}}>
                                    <div className="portion-field">
                                        <span>BP:</span>
                                        <input
                                            className="portion-input"
                                            type="number"
                                            value={currentRecipe.basePortions || currentRecipe.portions}
                                            onChange={(e) => {
                                                startEdit('basePortions', currentRecipe.id, null, null, e.target.value);
                                                setEditValue(e.target.value);
                                            }}
                                            onBlur={handleSend}
                                            title="Base Portions (original recipe)"
                                        />
                                    </div>
                                    <div className="portion-field">
                                        <span>TP:</span>
                                        <input
                                            className="portion-input"
                                            type="number"
                                            value={currentRecipe.targetPortions || currentRecipe.basePortions || currentRecipe.portions}
                                            onChange={(e) => {
                                                const newTarget = parseInt(e.target.value) || 1;
                                                setRecipes(prev => prev.map(r =>
                                                    r.id === currentRecipe.id
                                                        ? {...r, targetPortions: newTarget}
                                                        : r
                                                ));
                                                setCurrentRecipe(prev => ({...prev, targetPortions: newTarget}));
                                            }}
                                            style={{borderColor: '#27ae60', fontWeight: 'bold'}}
                                            title="Target Portions (scales ingredients)"
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Ingredients Section */}
                            <div className="section">
                                {(() => {
                                    const isScaled = (currentRecipe.targetPortions || currentRecipe.basePortions || currentRecipe.portions) !== (currentRecipe.basePortions || currentRecipe.portions);
                                    return (
                                        <>
                                            <div style={{display: 'flex', alignItems: 'center', gap: '8px', marginBottom: isScaled ? '10px' : '0'}}>
                                                <div className="section-header" style={{marginBottom: 0}}>Ingredients</div>
                                                {isUnlocked && (
                                                    <>
                                                        <button
                                                            className="add-button"
                                                            onClick={handleAddIngredient}
                                                            style={{fontSize: '14px', padding: '6px 12px', width: 'auto', marginTop: 0, opacity: isScaled ? 0.5 : 1, cursor: isScaled ? 'not-allowed' : 'pointer'}}
                                                            disabled={isScaled}
                                                        >
                                                            + Add
                                                        </button>
                                                        <button
                                                            className={bulkDictating ? "voice-button active" : "voice-button"}
                                                            onClick={handleDictateList}
                                                            style={{fontSize: '14px', padding: '6px 12px', width: 'auto', background: bulkDictating ? '#e74c3c' : '#3498db', opacity: isScaled ? 0.5 : 1, cursor: isScaled ? 'not-allowed' : 'pointer'}}
                                                            disabled={isScaled}
                                                        >
                                                            {bulkDictating ? '‚èπÔ∏è Stop' : 'üé§ Dictate'}
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                            {isScaled && (
                                                <div style={{background: '#3498db', color: 'white', padding: '10px', borderRadius: '5px', marginBottom: '15px', fontSize: '14px'}}>
                                                    ‚ÑπÔ∏è Recipe is scaled for {currentRecipe.targetPortions || currentRecipe.portions} portions (base: {currentRecipe.basePortions || currentRecipe.portions}).
                                                    Ingredient editing is disabled. Reset target portions to base to edit.
                                                </div>
                                            )}
                                        </>
                                    );
                                })()}
                                {/* Sort ingredients: ungrouped first, then grouped */}
                                {[...currentRecipe.ingredients]
                                    .map((ing, originalIdx) => ({ ...ing, originalIdx }))
                                    .sort((a, b) => {
                                        if (a.grouped === b.grouped) return 0;
                                        return a.grouped ? 1 : -1;
                                    })
                                    .map((ing, displayIdx) => {
                                    const idx = ing.originalIdx; // Use original index for all operations
                                    const isScaled = (currentRecipe.targetPortions || currentRecipe.basePortions || currentRecipe.portions) !== (currentRecipe.basePortions || currentRecipe.portions);
                                    const measurement = ing.measurement || {};

                                    // Calculate scaled value on-the-fly if targetPortions differs from basePortions
                                    let displayMeasurement = measurement;
                                    if (isScaled && measurement.value) {
                                        const basePortions = currentRecipe.basePortions || currentRecipe.portions;
                                        const targetPortions = currentRecipe.targetPortions || basePortions;
                                        const scale = targetPortions / basePortions;

                                        const scaledValue = measurement.value * scale;
                                        const normalized = normalizeUnit({
                                            ...measurement,
                                            value: scaledValue,
                                            displayValue: String(scaledValue.toFixed(2)).replace(/\.?0+$/, '')
                                        });
                                        displayMeasurement = normalized;
                                    }

                                    const measurementDisplay = displayMeasurement.value
                                        ? `${displayMeasurement.displayValue || displayMeasurement.value} ${displayMeasurement.unit}`
                                        : '‚Äî';

                                    // Get current grouped state from original recipe (not sorted array)
                                    const isGrouped = currentRecipe.ingredients[idx]?.grouped || false;

                                    return (
                                    <div key={idx} className={`ingredient-row ${isGrouped ? 'grouped' : ''}`}>
                                        <button
                                            className="group-checkbox-btn"
                                            onClick={() => {
                                                if (!isUnlocked || isScaled) return;
                                                handleToggleGroup(idx);
                                            }}
                                            disabled={isScaled}
                                            style={{
                                                background: 'transparent',
                                                border: '2px solid #95a5a6',
                                                borderRadius: '4px',
                                                width: '20px',
                                                height: '20px',
                                                cursor: isScaled ? 'not-allowed' : 'default',
                                                opacity: isScaled ? 0.3 : 1,
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                fontSize: '12px',
                                                color: '#3498db',
                                                padding: 0,
                                                pointerEvents: !isUnlocked ? 'none' : 'auto'
                                            }}
                                            title={isScaled ? "Cannot group when scaled" : ""}
                                        >
                                            {isGrouped ? '‚òë' : ''}
                                        </button>
                                        <div
                                            className={`ingredient-cell ${editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'measurement' ? 'editing' : ''}`}
                                            onClick={() => !isScaled && startEdit('ingredient', currentRecipe.id, idx, 'measurement', measurementDisplay)}
                                            style={{cursor: isScaled ? 'not-allowed' : 'pointer', opacity: isScaled ? 0.7 : 1}}
                                        >
                                            {editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'measurement' && !isScaled ? (
                                                <input
                                                    ref={inputRef}
                                                    className="edit-input"
                                                    value={editValue}
                                                    onChange={(e) => setEditValue(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                    onBlur={handleSend}
                                                    placeholder="ex: 800 gr"
                                                />
                                            ) : measurementDisplay}
                                        </div>
                                        <div
                                            className={`ingredient-cell ${editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'name' ? 'editing' : ''}`}
                                            onClick={() => !isScaled && startEdit('ingredient', currentRecipe.id, idx, 'name', ing.name)}
                                            style={{cursor: isScaled ? 'not-allowed' : 'pointer', opacity: isScaled ? 0.7 : 1}}
                                        >
                                            {editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'name' && !isScaled ? (
                                                <input
                                                    ref={inputRef}
                                                    className="edit-input"
                                                    value={editValue}
                                                    onChange={(e) => setEditValue(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                    onBlur={handleSend}
                                                />
                                            ) : (ing.name || 'Ingredient')}
                                        </div>
                                        <div
                                            className={`ingredient-cell ${editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'spec' ? 'editing' : ''}`}
                                            onClick={() => !isScaled && startEdit('ingredient', currentRecipe.id, idx, 'spec', ing.spec)}
                                            style={{cursor: isScaled ? 'not-allowed' : 'pointer', opacity: isScaled ? 0.7 : 1}}
                                        >
                                            {editingCell?.type === 'ingredient' && editingCell?.index === idx && editingCell?.field === 'spec' && !isScaled ? (
                                                <input
                                                    ref={inputRef}
                                                    className="edit-input"
                                                    value={editValue}
                                                    onChange={(e) => setEditValue(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                    onBlur={handleSend}
                                                />
                                            ) : (ing.spec || '‚Äî')}
                                        </div>
                                        <button
                                            className="delete-row-btn"
                                            onClick={() => !isScaled && handleDeleteIngredient(idx)}
                                            title={isScaled ? "Cannot delete when scaled" : "Delete ingredient"}
                                            style={{opacity: isScaled ? 0.3 : 0.5, cursor: isScaled ? 'not-allowed' : 'pointer'}}
                                            disabled={isScaled}
                                        >
                                            üóëÔ∏è
                                        </button>
                                        {editingCell?.type === 'ingredient' && editingCell?.index === idx && (
                                            <div className="edit-buttons" style={{position: 'absolute', right: '60px', display: 'flex', gap: '5px'}}>
                                                <button className="edit-btn delete" onMouseDown={handleDelete}>‚úï</button>
                                            </div>
                                        )}
                                    </div>
                                    );
                                })}
                            </div>

                            {/* Method Section */}
                            <div className="section">
                                <div style={{display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '0'}}>
                                    <div className="section-header" style={{marginBottom: 0}}>Method</div>
                                    {isUnlocked && (
                                        <>
                                            <button
                                                className="add-button"
                                                onClick={handleAddMethod}
                                                style={{fontSize: '14px', padding: '6px 12px', width: 'auto', marginTop: 0}}
                                            >
                                                + Add
                                            </button>
                                            <button
                                                className={bulkDictatingMethod ? "voice-button active" : "voice-button"}
                                                onClick={handleDictateMethodList}
                                                style={{fontSize: '14px', padding: '6px 12px', width: 'auto', background: bulkDictatingMethod ? '#e74c3c' : '#3498db'}}
                                            >
                                                {bulkDictatingMethod ? '‚èπÔ∏è Stop' : 'üé§ Dictate'}
                                            </button>
                                        </>
                                    )}
                                </div>
                                {currentRecipe.method.map((step, idx) => {
                                    const instruction = typeof step === 'string' ? step : (step.instruction || '');
                                    return (
                                    <div key={idx} className="step-row">
                                        <div className="step-number">{idx + 1}.</div>
                                        <div
                                            className={`step-text ${editingCell?.type === 'method' && editingCell?.index === idx ? 'editing' : ''}`}
                                            onClick={() => startEdit('method', currentRecipe.id, idx, null, instruction)}
                                        >
                                            {editingCell?.type === 'method' && editingCell?.index === idx ? (
                                                <input
                                                    ref={inputRef}
                                                    className="edit-input"
                                                    value={editValue}
                                                    onChange={(e) => setEditValue(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                    onBlur={handleSend}
                                                />
                                            ) : (instruction || 'Step description')}
                                        </div>
                                        {editingCell?.type === 'method' && editingCell?.index === idx && (
                                            <div className="edit-buttons">

                                                <button className="edit-btn delete" onMouseDown={handleDelete}>‚úï</button>
                                            </div>
                                        )}
                                        <button
                                            className="delete-row-btn"
                                            onClick={() => handleDeleteMethod(idx)}
                                            title="Delete step"
                                        >
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                    );
                                })}
                            </div>

                            {/* Plating Section */}
                            <div className="section">
                                <div style={{display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '0'}}>
                                    <div className="section-header" style={{marginBottom: 0}}>Plating & Packaging</div>
                                    {isUnlocked && (
                                        <>
                                            <button
                                                className="add-button"
                                                onClick={handleAddPlating}
                                                style={{fontSize: '14px', padding: '6px 12px', width: 'auto', marginTop: 0}}
                                            >
                                                + Add
                                            </button>
                                            <button
                                                className={bulkDictatingPlating ? "voice-button active" : "voice-button"}
                                                onClick={handleDictatePlatingList}
                                                style={{fontSize: '14px', padding: '6px 12px', width: 'auto', background: bulkDictatingPlating ? '#e74c3c' : '#3498db'}}
                                            >
                                                {bulkDictatingPlating ? '‚èπÔ∏è Stop' : 'üé§ Dictate'}
                                            </button>
                                        </>
                                    )}
                                </div>
                                {currentRecipe.plating.map((instruction, idx) => (
                                    <div key={idx} className="step-row">
                                        <div className="step-number">{idx + 1}.</div>
                                        <div 
                                            className={`step-text ${editingCell?.type === 'plating' && editingCell?.index === idx ? 'editing' : ''}`}
                                            onClick={() => startEdit('plating', currentRecipe.id, idx, null, instruction)}
                                        >
                                            {editingCell?.type === 'plating' && editingCell?.index === idx ? (
                                                <input
                                                    ref={inputRef}
                                                    className="edit-input"
                                                    value={editValue}
                                                    onChange={(e) => setEditValue(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                                    onBlur={handleSend}
                                                />
                                            ) : (instruction || 'Plating instruction')}
                                        </div>
                                        {editingCell?.type === 'plating' && editingCell?.index === idx && (
                                            <div className="edit-buttons">

                                                <button className="edit-btn delete" onMouseDown={handleDelete}>‚úï</button>
                                            </div>
                                        )}
                                        <button
                                            className="delete-row-btn"
                                            onClick={() => handleDeletePlating(idx)}
                                            title="Delete plating instruction"
                                        >
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                ))}
                            </div>

                            {isNewRecipe && (
                                <button className="save-button" onClick={handleSaveNewRecipe}>
                                    Save Recipe
                                </button>
                            )}
                        </div>
                    )}

                    {/* ==================== PDF IMPORT PREVIEW MODAL START ==================== */}
                    {previewRecipe && (
                        <div style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: 'rgba(0,0,0,0.7)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            zIndex: 10000,
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'white',
                                borderRadius: '10px',
                                padding: '30px',
                                maxWidth: '800px',
                                maxHeight: '90vh',
                                overflow: 'auto',
                                boxShadow: '0 4px 20px rgba(0,0,0,0.3)'
                            }}>
                                <h2 style={{marginTop: 0, color: '#2c3e50'}}>üìÑ Preview Imported Recipe</h2>

                                <div style={{marginBottom: '20px'}}>
                                    <strong>Name:</strong> {previewRecipe.name}<br/>
                                    <strong>Category:</strong> {previewRecipe.category}<br/>
                                    <strong>Portions:</strong> {previewRecipe.portions}
                                </div>

                                <div style={{marginBottom: '20px'}}>
                                    <strong>Ingredients ({previewRecipe.ingredients?.length || 0}):</strong>
                                    <ul style={{margin: '10px 0', paddingLeft: '20px'}}>
                                        {previewRecipe.ingredients?.map((ing, idx) => (
                                            <li key={idx}>
                                                {ing.measurement?.value} {ing.measurement?.unit} {ing.name} {ing.spec && `(${ing.spec})`}
                                            </li>
                                        ))}
                                    </ul>
                                </div>

                                <div style={{marginBottom: '20px'}}>
                                    <strong>Method Steps ({previewRecipe.method?.length || 0}):</strong>
                                    <ol style={{margin: '10px 0', paddingLeft: '20px'}}>
                                        {previewRecipe.method?.map((step, idx) => (
                                            <li key={idx}>{step.instruction}</li>
                                        ))}
                                    </ol>
                                </div>

                                {previewRecipe.plating && previewRecipe.plating.length > 0 && (
                                    <div style={{marginBottom: '20px'}}>
                                        <strong>Plating ({previewRecipe.plating.length}):</strong>
                                        <ul style={{margin: '10px 0', paddingLeft: '20px'}}>
                                            {previewRecipe.plating.map((instruction, idx) => (
                                                <li key={idx}>{instruction}</li>
                                            ))}
                                        </ul>
                                    </div>
                                )}

                                <div style={{display: 'flex', gap: '10px', marginTop: '30px'}}>
                                    <button
                                        onClick={handleAcceptPDFRecipe}
                                        style={{
                                            flex: 1,
                                            padding: '12px 24px',
                                            background: '#27ae60',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '5px',
                                            fontSize: '16px',
                                            cursor: 'pointer',
                                            fontWeight: 'bold'
                                        }}
                                    >
                                        ‚úì Add to Collection
                                    </button>
                                    <button
                                        onClick={handleCancelPDFImport}
                                        style={{
                                            flex: 1,
                                            padding: '12px 24px',
                                            background: '#e74c3c',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '5px',
                                            fontSize: '16px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        ‚úï Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    {/* ==================== PDF IMPORT PREVIEW MODAL END ==================== */}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>

    <!-- Service Worker Registration for PWA -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        console.log('‚úÖ Service Worker registered successfully:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('‚ùå Service Worker registration failed:', error);
                    });
            });
        } else {
            console.log('‚ö†Ô∏è Service Workers not supported in this browser');
        }
    </script>
</body>
</html>